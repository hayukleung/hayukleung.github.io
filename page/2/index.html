<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>xThinker | Android相关</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="梁夏旭的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="xThinker">
<meta property="og:url" content="https://hayukleung.github.io/page/2/index.html">
<meta property="og:site_name" content="xThinker">
<meta property="og:description" content="梁夏旭的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xThinker">
<meta name="twitter:description" content="梁夏旭的个人博客">
  
    <link rel="alternative" href="/atom.xml" title="xThinker" type="application/atom+xml">
  
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner">
  <a href="javascript:;" class="header-icon waves-circle-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/avatar.png"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Hayuk Leung</h5>
        <a href="mailto:undefined" title="hayukleung@gmail.com" class="mail">hayukleung@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav">
    
        <li class="waves-block active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            Home
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Category
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/tags/android"  >
            <i class="icon icon-lg icon-android"></i>
            Android
          </a>
        </li>
    
        <li class="waves-block">
          <a href="https://github.com/hayukleung" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block">
          <a href="http://www.weibo.com/liangxiaxu" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>
            Weibo
          </a>
        </li>
    
        <li class="waves-block">
          <a href="http://hayukleung.duapp.com" target="_blank" >
            <i class="icon icon-lg icon-link"></i>
            WordPress
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>xThinker &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-circle-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">xThinker</div>
        
        <a href="javascript:;" class="header-icon waves-circle-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">xThinker</h1>
    <h5 class="subtitle">Android相关</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <ul class="post-list">
  
    <li class="post-list-item">
  <article id="post-SQLite临时文件及其编译参数" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/09/SQLite临时文件及其编译参数/">SQLite临时文件及其编译参数</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/database/">database</a></li></ul>
</div>
        <time datetime="2012-09-09T13:23:50.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-09
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/09/2677339.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="一、临时文件"><a href="#一、临时文件" class="headerlink" title="一、临时文件"></a>一、临时文件</h2><p>尽管SQLite的数据库是由单一文件构成，然而事实上在SQLite运行时却存在着一些隐含的临时文件，这些临时文件是出于不同的目的而存在的，对于开发者而言，它们是透明的，因此在开发的过程中我们并不需要关注它们的存在。尽管如此，如果能对这些临时文件的产生机制和应用场景有着很好的理解，那么对我们今后应用程序的优化和维护都是极有帮助的。在SQLite中主要产生以下七种临时文件，如：<br>      1). 回滚日志。<br>      2). 主数据库日志。<br>      3). SQL语句日志。<br>      4). 临时数据库文件。<br>      5). 视图和子查询的临时持久化文件。<br>      6). 临时索引文件。<br>      7). VACUUM命令使用的临时数据库文件。</p>
<ol>
<li>回滚日志<br>   SQLite为了保证事务的原子性提交和回滚，在事务开始时创建了该临时文件。此文件始终位于和数据库文件相同的目录下，其文件名格式为: 数据库文件名+ “-journal”。换句话说，如果没有该临时文件的存在，当程序运行的系统出现任何故障时，SQLite将无法保证事务的完整性，以及数据状态的一致性。该文件在事务提交或回滚后将被立刻删除。在事务运行期间，如果当前主机因电源故障而宕机，而此时由于回滚日志文件已经保存在磁盘上，那么当下一次程序启动时，SQLite在打开数据库文件的过程中将会发现该临时文件的存在，我们称这种日志文件为”Hot Journal”。SQLite会在成功打开数据库之前先基于该文件完成数据库的恢复工作，以保证数据库的数据回复到上一个事务开始之前的状态。<br>   在SQLite中我们可以通过修改pragma journal_mode，而使SQLite对维护该文件采用不同的策略。缺省情况下该值为DELETE，即在事务结束后删除日志文件。而PERSIST选项值将不会删除日志文件，而是将回滚日志文件的头部清零，从而避免了文件删除所带的磁盘开销。再有就是OFF选项值，该值将指示SQLite在开始事务时不产生回滚日志文件，这样一旦出现系统故障，SQLite也无法再保障数据库数据的一致性。 </li>
<li>主数据库日志<br>   在SQLite中，如果事务的操作作用于多个数据库，即通过ATTACH命令附加到当前连接中的数据库，那么SQLite将生成主数据库日志文件以保证事务产生的改变在多个数据库之间保持原子性。和回滚日志文件一样，主数据库日志文件也位于当前连接中主数据库文件所处的目录内，其文件名格式为：主数据库文件名+ 随机的后缀。在该文件中，将包含所有当前事务将会改变的Attached数据库的名字。在事务被提交之后，此文件亦被SQLite随之删除。<br>   主数据库日志文件只有在某一事务同时操作多个数据库时(主数据库和Attached数据库)才有可能被创建。通过该文件，SQLite可以实现跨多个数据库的事务原子性，否则，只能简单的保证每个单一的数据库内的状态一致性。换句话说，如果该事务在执行的过程中出现系统崩溃或主机宕机的现象，在进行数据恢复时，若没有该文件的存在，将会导致部分SQLite数据库处于提交状态，而另外一部分则处于回滚状态，因此该事务的一致性将被打破。 </li>
<li>SQL语句日志<br>   在一个较大的事务中，SQLite为了保证部分数据在出现错误时可以被正常回滚，所以在事务开始时创建了SQL语句日志文件。比如，update语句修改了前50条数据，然而在修改第51条数据时发现该操作将会破坏某字段的唯一性约束，最终SQLite将不得不通过该日志文件回滚已经修改的前50条数据。<br>   SQL语句日志文件只有在INSERT或UPDATE语句修改多行记录时才有可能被创建，与此同时，这些操作还极有可能会打破某些约束并引发异常。但是如果INSERT或UPDATE语句没有被包含在BEGIN…COMMIT中，同时也没有任何其它的SQL语句正在当前的连接上运行，在这种情况下，SQLite将不会创建SQL语句日志文件，而是简单的通过回滚日志来完成部分数据的UNDO操作。<br>   和上面两种临时文件不同的是，SQL语句日志文件并不一定要存储在和数据库文件相同的目录下，其文件名也是随机生成。该文件所占用的磁盘空间需要视UPDATE或INSERT语句将要修改的记录数量而定。在事务结束后，该文件将被自动删除。 </li>
<li>临时数据库文件<br>   当使用”CREATE TEMP TABLE”语法创建临时数据表时，该数据表仅在当前连接内可见，在当前连接被关闭后，临时表也随之消失。然而在生命期内，临时表将连同其相关的索引和视图均会被存储在一个临时的数据库文件之内。该临时文件是在第一次执行”CREATE TEMP TABLE”时即被创建的，在当前连接被关闭后，该文件亦将被自动删除。最后需要说明的是，临时数据库不能被执行DETACH命令，同时也不能被其它进程执行ATTACH命令。 </li>
<li>视图和子查询的临时持久化文件<br>   在很多包含子查询的查询中，SQLite的执行器会将该查询语句拆分为多个独立的SQL语句，同时将子查询的结果持久化到临时文件中，之后在基于该临时文件中的数据与外部查询进行关联，因此我们可以称其为物化子查询。通常而言，SQLite的优化器会尽力避免子查询的物化行为，但是在有些时候该操作是无法避免的。该临时文件所占用的磁盘空间需要依赖子查询检索出的数据数量，在查询结束后，该文件将被自动删除。见如下示例：<br>   SELECT <em> FROM ex1 WHERE ex1.a IN (SELECT b FROM ex2);<br>   在上面的查询语句中，子查询SELECT b FROM ex2的结果将会被持久化到临时文件中，外部查询在运行时将会为每一条记录去检查该临时文件，以判断当前记录是否出现在临时文件中，如果是则输出当前记录。显而易见的是，以上的行为将会产生大量的IO操作，从而显著的降低了查询的执行效率，为了避免临时文件的生成，我们可以将上面的查询语句改为：<br>   SELECT </em> FROM ex1 WHERE EXISTS(SELECT 1 FROM ex2 WHERE ex2.b=ex1.a);<br>   对于如下查询语句，如果SQLite不做任何智能的rewrite操作，该查询中的子查询也将会被持久化到临时文件中，如：<br>   SELECT <em> FROM ex1 JOIN (SELECT b FROM ex2) AS t ON t.b=ex1.a;<br>   在SQLite自动将其修改为下面的写法后，将不会再生成临时文件了，如：<br>   SELECT ex1.</em>, ex2.b FROM ex1 JOIN ex2 ON ex2.b=ex1.a; </li>
<li>临时索引文件<br>   当查询语句包含以下SQL从句时，SQLite为存储中间结果而创建了临时索引文件，如：<br>   1). ORDER BY或GROUP BY从句。<br>   2). 聚集查询中的DISTINCT关键字。<br>   3). 由UNION、EXCEPT和INTERSECT连接的多个SELECT查询语句。<br>   需要说明的是，如果在指定的字段上已经存在了索引，那么SQLite将不会再创建该临时索引文件，而是通过直接遍历索引来访问数据并提取有用信息。如果没有索引，则需要将排序的结果存储在临时索引文件中以供后用。该临时文件所占用的磁盘空间需要依赖排序数据的数量，在查询结束后，该文件被自动删除。 </li>
<li>VACUUM命令使用的临时数据库文件<br>   VACUUM命令在工作时将会先创建一个临时文件，然后再将重建的整个数据库写入到该临时文件中。之后再将临时文件中的内容拷贝回原有的数据库文件中，最后删除该临时文件。<br>   该临时文件所占用的磁盘空间不会超过原有文件的尺寸。<h2 id="二、相关的编译时参数和指令"><a href="#二、相关的编译时参数和指令" class="headerlink" title="二、相关的编译时参数和指令"></a>二、相关的编译时参数和指令</h2>对于SQLite来说，回滚日志、主数据库日志和SQL语句日志文件在需要的时候SQLite都会将它们写入磁盘文件，但是对于其它类型的临时文件，SQLite是可以将它们存放在内存中以取代磁盘文件的，这样在执行的过程中就可以减少大量的IO操作了。要完成该优化主要依赖于以下三个因素： </li>
<li>编译时参数SQLITE_TEMP_STORE<br>   该参数是源代码中的宏定义(#define)，其取值范围是0到3(缺省值为1)，见如下说明：<br>   1). 等于0时，临时文件总是存储在磁盘上，而不会考虑pragma temp_store指令的设置。<br>   2). 等于1时，临时文件缺省存储在磁盘上，但是该值可以被pragma temp_store指令覆盖。<br>   3). 等于2时，临时文件缺省存储在内存中，但是该值可以被pragma temp_store指令覆盖。<br>   4). 等于3时，临时文件总是存储在内存中，而不会考虑pragma temp_store指令的设置。 </li>
<li>运行时指令pragma temp_store<br>   该指令的取值范围是0到2(缺省值为0)，在程序运行时该指令可以被动态的设置，见如下说明：<br>   1). 等于0时，临时文件的存储行为完全由SQLITE_TEMP_STORE编译期参数确定。<br>   2). 等于1时，如果编译期参数SQLITE_TEMP_STORE指定使用内存存储临时文件，那么该指令将覆盖这一行为，使用磁盘存储。<br>   3). 等于2时，如果编译期参数SQLITE_TEMP_STORE指定使用磁盘存储临时文件，那么该指令将覆盖这一行为，使用内存存储。<ul>
<li>pragma temp_store_directory用于更改磁盘日志位置。</li>
<li>当改变temp_store设置，所有已存在的临时表、索引、触发器及视图将被立即删除。 </li>
</ul>
</li>
<li>临时文件的大小<br>   对于以上两个参数，都有参数值表示缺省情况是存储在内存中的，只有当临时文件的大小超过一定的阈值后才会根据一定的算法，将部分数据写入到磁盘中，以免临时文件占用过多的内存而影响其它程序的执行效率。<br>   最后在重新赘述一遍，SQLITE_TEMP_STORE编译期参数和pragma temp_store运行时指令只会影响除回滚日志和主数据库日志之外的其它临时文件的存储策略。换句话说，回滚日志和主数据库日志将总是将数据写入磁盘，而不会关注以上两个参数的值。<h2 id="三、其它优化策略"><a href="#三、其它优化策略" class="headerlink" title="三、其它优化策略"></a>三、其它优化策略</h2>在SQLite中由于采用了Page Cache的缓冲优化机制，因此即便临时文件被指定存储在磁盘上，也只有当该文件的大小增长到一定的尺寸后才有可能被SQLite刷新到磁盘文件上，在此之前它们仍将驻留在内存中。这就意味着对于大多数场景，如果临时表和临时索引的数据量相对较少，那么它们是不会被写到磁盘中的，当然也就不会有IO事件发生。只有当它们增长到内存不能容纳的时候才会被刷新到磁盘文件中的。其中SQLITE_DEFAULT_TEMP_CACHE_SIZE编译期参数可以用于指定临时表和索引在占用多少Cache Page时才需要被刷新到磁盘文件，该参数的缺省值为500页。</li>
</ol>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/09/SQLite临时文件及其编译参数/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-inline-in-cpp" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/02/inline-in-cpp/">inline-in-cpp</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-09-02T14:13:10.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-02
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667395.html" target="_blank" rel="external">原文地址</a></p>
<p>与宏的比较<br>内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TABLE_COMP(x) ((x)&gt;0?(x):0)</span><br></pre></td></tr></table></figure></p>
<p>就定义了一个宏。<br>为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。<br>但是宏也有很多的不尽人意的地方。<br>1、宏不能访问对象的私有成员。<br>2、宏的定义很容易产生二意性。<br>我们举个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TABLE_MULTI(x) (x*x)</span><br></pre></td></tr></table></figure></p>
<p>我们用一个数字去调用它：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE_MULTI(10);</span><br></pre></td></tr></table></figure></p>
<p>这样看上去没有什么错误，结果返回100是正确的，但是如果我们用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE_MULTI(10+10);</span><br></pre></td></tr></table></figure></p>
<p>去调用的话，我们期望的结果是400，而宏的调用结果是(10+10*10+10)，结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TABLE_MULTI(x) ((x)*(x))</span><br></pre></td></tr></table></figure></p>
<p>这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TABLE_MULTI(a++);</span><br></pre></td></tr></table></figure></p>
<p>调用它，他们本意是希望得到(a+1)<em>(a+1)的结果，而实际上呢？我们可以看看宏的展开结果：(a++)</em>(a++)，如果a的值是4，我们得到的结果是4<em>4 = 16，a = 6。而我们期望的结果是5</em>5=25，这又出现了问题。<br>事实上，在一些C的库函数中也有这些问题。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Toupper(*pChar++);</span><br></pre></td></tr></table></figure></p>
<p>就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。<br>我们可以看到宏有一些难以避免的问题，怎么解决呢？<br>下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。<br>内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。<br>我们可以用inline来定义内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。<br>下面我们来介绍一下内联函数的用法。<br>内联函数必须是和函数体申明在一起，才有效。像这样的申明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline Tablefunction(int I);</span><br></pre></td></tr></table></figure></p>
<p>是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline tablefunction(int I) &#123;return I*I&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。<br>我们也可以将定义在类的外部的函数定义为内联函数，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class TableClass</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int I,j;</span><br><span class="line">public:</span><br><span class="line">    int add() &#123; return I+j;&#125;;</span><br><span class="line">    inline int dec() &#123; return I-j;&#125;</span><br><span class="line">    int GetNum(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline int tableclass::GetNum()</span><br><span class="line">&#123;</span><br><span class="line">    return I;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面申明的三个函数都是内联函数。在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。<br>内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。<br>对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class sample</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">    int nTest;</span><br><span class="line">public:</span><br><span class="line">    int readtest() &#123; return nTest;&#125;</span><br><span class="line">    void settest(int I) &#123;nTest=I;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。<br>使用内联函数应注意的事项<br>内联函数具有一般函数的特性，它与一般函数所不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。在使用内联函数时，应注意如下几点：<br>1.在内联函数内不允许用循环语句和开关语句。<br>如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数（自己调用自己的函数）是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。<br>2.内联函数的定义必须出现在内联函数第一次被调用之前。<br>3.本栏目讲到的类结构中所有在类说明内部定义的函数是内联函数。</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/02/inline-in-cpp/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-extern-c" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/02/extern-c/">extern-c</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-09-02T10:42:11.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-02
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667730.html" target="_blank" rel="external">原文链接</a></p>
<h2 id="extern-“C”的双重含义"><a href="#extern-“C”的双重含义" class="headerlink" title="extern “C”的双重含义"></a>extern “C”的双重含义</h2><p>1.被它修饰的目标是“extern ”；<br>2.被它修饰的目标是“C ”。<br>让我们来详细解读这两重含义。<br>被extern “C”限定的函数或变量是extern类型的。<br>extern 是C/C++ 语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。记住下列语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern int a;</span><br></pre></td></tr></table></figure></p>
<p>仅仅是一个变量的声明，其并不是在定义变量a ，并未为a 分配内存空间。变量a 在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。<br>引用一个定义在其它模块的全局变量或函数（如全局函数或变量定义在A 模块，B 欲引用）有两种方法：<br>1.B 模块中include 模块A 的头文件；<br>2.模块B 中对欲引用的模块A 的变量或函数重新声明一遍，并前加extern 关键字。<br>通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern 声明。例如，如果模块B 欲引用该模块A 中定义的全局变量和函数时只需包含模块A 的头文件即可。这样，模块B 中调用模块A 中的函数时，在编译阶段，模块B 虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A 编译生成的目标代码中找到此函数。<br>与extern 对应的关键字是static ，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern “C” 修饰。<br>被extern “C” 修饰的变量和函数是按照C 语言方式编译和连接的。</p>
<h2 id="未加extern-“C”-声明时的编译方式"><a href="#未加extern-“C”-声明时的编译方式" class="headerlink" title="未加extern “C” 声明时的编译方式"></a>未加extern “C” 声明时的编译方式</h2><p>首先看看C++ 中对类似C 的函数是怎样编译的。<br>作为一种面向对象的语言，C++ 支持函数重载，而过程式语言C 则不支持。函数被C++ 编译后在符号库中的名字与C 语言的不同。例如，假设某个函数的原型为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void foo(int x, int y);</span><br></pre></td></tr></table></figure></p>
<p>该函数被C 编译器编译后在符号库中的名字为_foo ，而C++ 编译器则会产生像_foo_int_int 之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name ”）。<br>_foo_int_int 这样的名字包含了函数名、函数参数数量及类型信息，C++ 就是靠这种机制来实现函数重载的。例如，在C++ 中，函数void foo(int x, int y) 与void foo(int x, float y) 编译生成的符号是不相同的，后者为_foo_int_float 。<br>同样地，C++ 中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以”.”来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。</p>
<h2 id="未加extern-“C”声明时的连接方式"><a href="#未加extern-“C”声明时的连接方式" class="headerlink" title="未加extern “C”声明时的连接方式"></a>未加extern “C”声明时的连接方式</h2><p>假设在C++ 中，模块A 的头文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模块A头文件moduleA.h</span><br><span class="line">#ifndef MODULE_A_H</span><br><span class="line">#define MODULE_A_H</span><br><span class="line">int foo(int x, int y);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>在模块B中引用该函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 模块B实现文件moduleB.cpp </span><br><span class="line">#include &quot;moduleA.h&quot;</span><br><span class="line">foo(2,3);</span><br></pre></td></tr></table></figure></p>
<p>实际上，在连接阶段，连接器会从模块A 生成的目标文件moduleA.obj 中寻找_foo_int_int 这样的符号。</p>
<h2 id="加extern-“C”-声明后的编译和连接方式"><a href="#加extern-“C”-声明后的编译和连接方式" class="headerlink" title="加extern “C” 声明后的编译和连接方式"></a>加extern “C” 声明后的编译和连接方式</h2><p>加extern “C”声明后，模块A的头文件变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 模块A头文件moduleA.h</span><br><span class="line">#ifndef MODULE_A_H</span><br><span class="line">#define MODULE_A_H</span><br><span class="line">extern &quot;C&quot; int foo(int x, int y);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>
<p>在模块B的实现文件中仍然调用foo(2, 3) ，其结果是：<br>1.模块A 编译生成foo 的目标代码时，没有对其名字进行特殊处理，采用了C 语言的方式；<br>2.连接器在为模块B 的目标代码寻找foo(2, 3) 调用时，寻找的是未经修改的符号名_foo 。<br>如果在模块A 中函数声明了foo 为extern “C” 类型，而模块B 中包含的是extern int foo(int x, int y) ，则模块B 找不到模块A 中的函数；反之亦然。<br>所以，可以用一句话概括extern “C” 这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现C++ 与C 及其它语言的混合编程。<br>明白了C++ 中extern “C” 的设立动机，我们下面来具体分析extern “C” 通常的使用技巧。</p>
<h2 id="extern-“C”的惯用法"><a href="#extern-“C”的惯用法" class="headerlink" title="extern “C”的惯用法"></a>extern “C”的惯用法</h2><p>（1）在C++ 中引用C 语言中的函数和变量，在包含C 语言头文件（假设为cExample.h ）时，需进行下列处理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;cExample.h&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而在C 语言的头文件中，对其外部函数只能指定为extern 类型，C 语言中不支持extern “C” 声明，在.c 文件中包含了extern “C” 时会出现编译语法错误（error: expected identifier or ‘(’ before string constant ）。</p>
<h2 id="C-引用C-函数工程例子"><a href="#C-引用C-函数工程例子" class="headerlink" title="C++ 引用C 函数工程例子"></a>C++ 引用C 函数工程例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">================</span><br><span class="line">. </span><br><span class="line">|-- Makefile </span><br><span class="line">|-- cEx.c </span><br><span class="line">|-- cEx.h </span><br><span class="line">|-- libcEx.so </span><br><span class="line">`-- test </span><br><span class="line">    |-- Makefile </span><br><span class="line">    |-- cppTest.cpp </span><br><span class="line">    `—test</span><br><span class="line">================</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//cEx_h</span><br><span class="line">#ifndef CEX_H</span><br><span class="line">#define CEX_H</span><br><span class="line">extern int add(int x, int y);</span><br><span class="line">#endif//CEX_H</span><br><span class="line">// vim: set tabstop=4 shiftwidth=4 expandtab:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//cEx_c</span><br><span class="line">#include &quot;cEx.h&quot;</span><br><span class="line">int add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">// vim: set tabstop=4 shiftwidth=4 expandtab:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//cppTest_cpp</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">#include &quot;cEx.h&quot;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    add(2, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// vim: set tabstop=4 shiftwidth=4 expandtab:</span><br></pre></td></tr></table></figure>
<p>如果C++ 调用一个C 语言编写的.DLL 时，当包括.DLL 的头文件或声明接口函数时，应加extern “C” {} 。<br>（2）在C 中引用C++ 语言中的函数和变量时，C++ 的头文件需添加extern “C” ，但是在C 语言中不能直接引用声明了extern “C” 的该头文件，应该仅将C 文件中将C++ 中定义的extern “C” 函数声明为extern 类型。</p>
<h2 id="C-引用C-函数工程例子-1"><a href="#C-引用C-函数工程例子-1" class="headerlink" title="C 引用C++ 函数工程例子"></a>C 引用C++ 函数工程例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">================</span><br><span class="line">. </span><br><span class="line">|-- Makefile </span><br><span class="line">|-- cppEx.cpp </span><br><span class="line">|-- cppEx.h </span><br><span class="line">|-- libcppEx.so </span><br><span class="line">`-- test </span><br><span class="line">    |-- Makefile </span><br><span class="line">    |-- cTest.c </span><br><span class="line">    `—test</span><br><span class="line">================</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//cppEx_h</span><br><span class="line">#ifndef CPPEX_H</span><br><span class="line">#define CPPEX_H</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    int add(int x, int y);</span><br><span class="line">&#125;</span><br><span class="line">#endif//CPPEX_H</span><br><span class="line">// vim: set tabstop=4 shiftwidth=4 expandtab:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//cppEx_cpp</span><br><span class="line">#include &quot;cppEx.h&quot;</span><br><span class="line">int add(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br><span class="line">// vim: set tabstop=4 shiftwidth=4 expandtab:</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//cTest_c</span><br><span class="line">//the func add is  defined in outside module</span><br><span class="line">extern int add(int x, int y);</span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    add(2, 3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">// vim: set tabstop=4 shiftwidth=4 expandtab:</span><br></pre></td></tr></table></figure>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/02/extern-c/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-const-in-cpp" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/01/const-in-cpp/">const-in-cpp</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-09-01T04:43:51.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-01
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/01/2666741.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="用const-修饰函数的参数"><a href="#用const-修饰函数的参数" class="headerlink" title="用const 修饰函数的参数"></a>用const 修饰函数的参数</h2><p>如果参数作输出用，不论它是什么数据类型，不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。<br>const 只能修饰输入参数：<br>(1) 如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。<br>例如StringCopy 函数：void StringCopy(char <em>strDestination, const char </em>strSource);<br>其中strSource 是输入参数，strDestination 是输出参数。给strSource 加上const 修饰后，如果函数体内的语句试图改动strSource 的内容，编译器将指出错误。<br>(2) 如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。<br>例如不要将函数void Func1(int x) 写成void Func1(const int x)。同理不要将函数void Func2(A a) 写成void Func2(const A a)。其中A 为用户自定义的数据类型。对于非内部数据类型的参数而言，象void Func(A a) 这样声明的函数注定效率比较底。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。<br>为了提高效率，可以将函数声明改为void Func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。但是函数void Func(A &amp;a) 存在一个缺点：“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const 修饰即可，因此函数最终成为void Func(const A &amp;a)。<br>以此类推，是否应将void Func(int x) 改写为void Func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。<br>(3) 将“const &amp; ”，修饰输入参数的用法总结一下。<br>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。<br>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。 </p>
<h2 id="用const-修饰函数的返回值"><a href="#用const-修饰函数的返回值" class="headerlink" title="用const 修饰函数的返回值"></a>用const 修饰函数的返回值</h2><p>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。<br>例如函数：const char <em> GetString(void);<br>如下语句将出现编译错误：<br>char </em>str = GetString();<br>正确的用法是const char *str = GetString();<br>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const 修饰没有任何价值。<br>例如不要把函数int GetInt(void) 写成const int GetInt(void)。同理不要把函数A GetA(void) 写成const A GetA(void)，其中A 为用户自定义的数据类型。<br>如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void) 的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。<br>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    A &amp; operate = (const A &amp; other); // 赋值函数</span><br><span class="line">&#125;;</span><br><span class="line">A a, b, c; // a, b, c 为A 的对象</span><br><span class="line">a = b = c; // 正常的链式赋值</span><br><span class="line">(a = b) = c; // 不正常的链式赋值，但合法</span><br></pre></td></tr></table></figure></p>
<p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动.<br>上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。 </p>
<h2 id="const-成员函数"><a href="#const-成员函数" class="headerlink" title="const 成员函数"></a>const 成员函数</h2><p>任何不会修改数据成员（即函数中的变量）的函数都应该声明为const 类型。如果在编写const 成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。<br>以下程序中，类stack 的成员函数GetCount 仅用于计数，从逻辑上讲GetCount 应当为const 函数。编译器将指出GetCount 函数中的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(int elem);</span><br><span class="line">    int Pop(void);</span><br><span class="line">    int GetCount(void) const; // const 成员函数</span><br><span class="line">private:</span><br><span class="line">    int m_num;</span><br><span class="line">    int m_data[100];</span><br><span class="line">&#125;;</span><br><span class="line">int Stack::GetCount(void) const</span><br><span class="line">&#123;</span><br><span class="line">    ++ m_num; // 编译错误，企图修改数据成员m_num</span><br><span class="line">    Pop(); // 编译错误，企图调用非const 函数</span><br><span class="line">    return m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>const 成员函数的声明看起来怪怪的：const 关键字只能放在函数声明的尾部。<br>关于const 函数的几点规则：<br>a. const 对象只能访问const 成员函数，而非const 对象可以访问任意的成员函数，包括const 成员函数。<br>b. const 对象的成员是不可修改的，然而const 对象通过指针维护的对象却是可以修改的。<br>c. const 成员函数不可以修改对象的数据，不管对象是否具有const 性质。它在编译时，以是否修改成员数据为依据，进行检查。<br>d. 加上mutable 修饰符的数据成员，对于任何情况下通过任何手段都可修改，自然此时的const 成员函数是可以修改它的。</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/01/const-in-cpp/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-文本相似度算法" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/05/文本相似度算法/">文本相似度算法</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/communication/">communication</a></li></ul>
</div>
        <time datetime="2012-05-05T14:25:40.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-05
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/05/2484972.html" target="_blank" rel="external">原文地址</a></p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/05/文本相似度算法/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-使用autotools制作makefile" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/05/使用autotools制作makefile/">使用autotools制作makefile</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-05-05T14:24:25.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-05
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/05/2485099.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="flat模式"><a href="#flat模式" class="headerlink" title="flat模式"></a>flat模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- ①#autoscan</span><br><span class="line">生成configure.scan</span><br><span class="line">- ②改写configure.scan</span><br><span class="line">AC_INIT(最终可执行文件名, 版本号)</span><br><span class="line">AM_INIT_AUTOMAKE</span><br><span class="line">AC_CONFIG_SRCDIR(源文件所在文件夹中的一个文件名，用于检测路径)</span><br><span class="line">AC_CONFIG_HEADER(config.h)</span><br><span class="line">AC_OUTPUT(Makefile)</span><br><span class="line">AC_PROG_RANLIB</span><br><span class="line">改写完毕后另存为configure.in</span><br><span class="line">- ③#aclocal</span><br><span class="line">- ④#autoconf</span><br><span class="line">- ⑤#autoheader</span><br><span class="line">- ⑥编辑Makefile.am</span><br><span class="line">AUTOMAKE_OPTIONS=foreign</span><br><span class="line">bin_PROGRAMS=可执行文件名1可执行文件名2 ......可执行文件名n</span><br><span class="line">可执行文件名1_SOURCES=该可执行文件生成所必须的源文件、头文件等，以空格分开</span><br><span class="line">可执行文件名2_SOURCES=该可执行文件生成所必须的源文件、头文件等，以空格分开</span><br><span class="line">......</span><br><span class="line">可执行文件名n_SOURCES=该可执行文件生成所必须的源文件、头文件等，以空格分开</span><br><span class="line">可执行文件名1_LDADD=-l库名</span><br><span class="line">......</span><br><span class="line">可执行文件名n_LDADD=-l库名</span><br><span class="line">- ⑦#automake --add-missing</span><br><span class="line">- ⑧#./configure</span><br><span class="line">- ⑨#make</span><br><span class="line">- ⑩生成可执行文件，运行。</span><br></pre></td></tr></table></figure>
<h2 id="deep模式"><a href="#deep模式" class="headerlink" title="deep模式"></a>deep模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">以例子说明</span><br><span class="line">环境：Linux Redhat Enterprise</span><br><span class="line">文件结构：</span><br><span class="line">根目录：</span><br><span class="line">/rtcp</span><br><span class="line">子目录：</span><br><span class="line">/rtcp/src：包含server.c client.c</span><br><span class="line">/rtcp/include：包含rtcp.c rtcp.h</span><br><span class="line">目标：在根目录/rtcp下建立Makefile</span><br><span class="line">步骤：</span><br><span class="line">- ①进入/rtcp</span><br><span class="line">#autoscan</span><br><span class="line">产生configure.scan</span><br><span class="line">修改该文件：</span><br><span class="line">AM_INIT_AUTOMAKE</span><br><span class="line"># Checks for programs.</span><br><span class="line">AC_PROG_CC </span><br><span class="line">AM_PROG_CC_C_O</span><br><span class="line"># Checks for libraries. </span><br><span class="line">AC_PROG_RANLIB</span><br><span class="line">AC_OUTPUT(Makefile)</span><br><span class="line">保存为configure.in</span><br><span class="line">- ②</span><br><span class="line">#aclocal</span><br><span class="line">#autoconf</span><br><span class="line">#autoheader</span><br><span class="line">#gedit Makefile.am</span><br><span class="line">- ③编辑Makefile.am</span><br><span class="line">AUTOMAKE_OPTIONS=subdir-objects </span><br><span class="line">bin_PROGRAMS=server client </span><br><span class="line">server_SOURCES=src/server.c include/rtcp.c include/rtcp.h </span><br><span class="line">client_SOURCES=src/client.c include/rtcp.c include/rtcp.h </span><br><span class="line">server_LDADD=-lpthread </span><br><span class="line">client_LDADD=-lpthread</span><br><span class="line">server_LDFLAGS=-L/path/to/lib/pthread/</span><br><span class="line">client_LDFLAGS=-L/path/to/lib/pthread/</span><br><span class="line">保存</span><br><span class="line">- ④#automake --add-missing</span><br><span class="line">- ⑤#./configure</span><br><span class="line">- ⑥#make</span><br></pre></td></tr></table></figure>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/05/使用autotools制作makefile/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Matlab作图：A律13折线" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/03/Matlab作图：A律13折线/">Matlab作图：A律13折线</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/communication/">communication</a></li></ul>
</div>
        <time datetime="2012-05-03T14:23:31.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-03
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/03/2481490.html" target="_blank" rel="external">原文地址</a></p>
<p>打开matlab，新建m文件，敲入以下代码后运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">x1=-1:0.001:-0.5;</span><br><span class="line">y1=0.25*x1-0.75;</span><br><span class="line">axis([-1.1,1.1,-1.1,1.1]);</span><br><span class="line">plot(x1,y1);</span><br><span class="line">hold on</span><br><span class="line">x2=-0.5:0.0001:-0.25;</span><br><span class="line">y2=0.5*x2-0.625;</span><br><span class="line">plot(x2,y2);</span><br><span class="line">x3=-0.25:0.00001:-0.125;</span><br><span class="line">y3=x3-0.5;</span><br><span class="line">plot(x3,y3);</span><br><span class="line">x4=-0.125:0.000001:-0.0625;</span><br><span class="line">y4=2*x4-0.375;</span><br><span class="line">plot(x4,y4);</span><br><span class="line">x5=-0.0625:0.0000001:-0.03125;</span><br><span class="line">y5=4*x5-0.25;</span><br><span class="line">plot(x5,y5);</span><br><span class="line">x6=-0.03125:0.0000001:-0.015625;</span><br><span class="line">y6=8*x6-0.125;</span><br><span class="line">plot(x6,y6);</span><br><span class="line">x7=-0.015625:0.0000001:0.015625;</span><br><span class="line">y7=16*x7;</span><br><span class="line">plot(x7,y7);</span><br><span class="line">x8=0.015625:0.0000001:0.03125;</span><br><span class="line">y8=8*x8+0.125;</span><br><span class="line">plot(x8,y8);</span><br><span class="line">x9=0.03125:0.0000001:0.0625;</span><br><span class="line">y9=4*x9+0.25;</span><br><span class="line">plot(x9,y9);</span><br><span class="line">x10=0.0625:0.000001:0.125;</span><br><span class="line">y10=2*x10+0.375;</span><br><span class="line">plot(x10,y10);</span><br><span class="line">x11=0.125:0.00001:0.25;</span><br><span class="line">y11=x11+0.5;</span><br><span class="line">plot(x11,y11);</span><br><span class="line">x12=0.25:0.0001:0.5;</span><br><span class="line">y12=0.5*x12+0.625;</span><br><span class="line">plot(x12,y12);</span><br><span class="line">x13=0.5:0.001:1;</span><br><span class="line">y13=0.25*x13+0.75;</span><br><span class="line">plot(x13,y13);</span><br><span class="line">grid on</span><br><span class="line">title(&apos;A律13折线&apos;);</span><br><span class="line">text(0,0,&apos;原点&apos;);</span><br><span class="line">set(gca,&apos;xtick&apos;,[-1:0.1:1]);</span><br><span class="line">set(gca,&apos;ytick&apos;,[-1:0.125:1]);</span><br></pre></td></tr></table></figure></p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/03/Matlab作图：A律13折线/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-模拟频率、数字频率与模拟角频率" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/02/模拟频率、数字频率与模拟角频率/">模拟频率、数字频率与模拟角频率</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/communication/">communication</a></li></ul>
</div>
        <time datetime="2012-05-02T14:19:48.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-02
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/02/2479843.html" target="_blank" rel="external">原文地址</a></p>
<p>概念：<br>模拟频率f：每秒经历多少个周期，单位Hz，即1/s<br>模拟角频率Ω：每秒经历多少弧度，单位rad/s<br>数字频率w：每个采样点间隔之间的弧度，单位rad</p>
<p>表达式：<br>模拟频率f：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(2pi*f*t)</span><br></pre></td></tr></table></figure></p>
<p>模拟角频率Ω：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(Ω*t)</span><br></pre></td></tr></table></figure></p>
<p>数字频率w：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(w*n)=cos(Ω*T*n) [T为采样间隔时间]</span><br></pre></td></tr></table></figure></p>
<p>关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ω=2pi*f</span><br><span class="line">w=Ω*T</span><br></pre></td></tr></table></figure></p>
<p>推导：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(2pi*f*t)=cos(Ω*t)=cos(Ω*n*T)=cos(Ω*T*n)=cos(w*n)</span><br></pre></td></tr></table></figure></p>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x(n)=sin(n*4*PI/7)的数字频率=4*PI/7</span><br></pre></td></tr></table></figure></p>
<p>关键点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=n*T</span><br></pre></td></tr></table></figure></p>
<p>从时域角度理解：<br>模拟信号周期：<br>经过2<em>pi需多长时间，单位s；<br>example：f = 10Hz，则周期0.1s；<br>数字信号周期：<br>经过2</em>pi需多少个点，单位1；<br>example：f = 10Hz，fs = 20Hz，则周期2；<br>基准关系是2*pi</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/02/模拟频率、数字频率与模拟角频率/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
  </ul>
  
    <nav id="page-nav">
      <div class="inner">
        <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
      </div>
    </nav>
  


    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-circle-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<div class="global-share" id="global-share" data-title="xThinker" data-pic="/img/avatar.png" data-summary="梁夏旭的个人博客" data-url="https://hayukleung.github.io/page/2/index.html">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>








</body>
</html>
