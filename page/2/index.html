<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>xThinker | Android相关</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="undefined">
  <meta name="description" content="梁夏旭的个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="xThinker">
<meta property="og:url" content="https://hayukleung.github.io/page/2/index.html">
<meta property="og:site_name" content="xThinker">
<meta property="og:description" content="梁夏旭的个人博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xThinker">
<meta name="twitter:description" content="梁夏旭的个人博客">
  
    <link rel="alternative" href="/atom.xml" title="xThinker" type="application/atom+xml">
  
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="loading" class="active"></div>

  <nav id="menu"  >
   <div class="inner">
  <a href="javascript:;" class="header-icon waves-circle-light" id="menu-off">
      <i class="icon icon-lg icon-close"></i>
  </a>
  <div class="brand-wrap">
    <div class="brand">
      <a href="/" class="avatar"><img src="/img/avatar.png"></a>
      <hgroup class="introduce">
        <h5 class="nickname">Hayuk Leung</h5>
        <a href="mailto:undefined" title="hayukleung@gmail.com" class="mail">hayukleung@gmail.com</a>
      </hgroup>
    </div>
  </div>
  <ul class="nav">
    
        <li class="waves-block active">
          <a href="/"  >
            <i class="icon icon-lg icon-home"></i>
            Home
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/archives"  >
            <i class="icon icon-lg icon-archives"></i>
            Archives
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/tags"  >
            <i class="icon icon-lg icon-tags"></i>
            Category
          </a>
        </li>
    
        <li class="waves-block">
          <a href="/tags/android"  >
            <i class="icon icon-lg icon-android"></i>
            Android
          </a>
        </li>
    
        <li class="waves-block">
          <a href="https://github.com/hayukleung" target="_blank" >
            <i class="icon icon-lg icon-github"></i>
            Github
          </a>
        </li>
    
        <li class="waves-block">
          <a href="http://www.weibo.com/liangxiaxu" target="_blank" >
            <i class="icon icon-lg icon-weibo"></i>
            Weibo
          </a>
        </li>
    
        <li class="waves-block">
          <a href="http://hayukleung.duapp.com" target="_blank" >
            <i class="icon icon-lg icon-link"></i>
            WordPress
          </a>
        </li>
    
  </ul>

  <footer class="footer">
  <p><a rel="license" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0;vertical-align:middle;" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAAAPCAMAAABEF7i9AAAAllBMVEUAAAD///+rsapERER3d3eIiIjMzMzu7u4iIiKUmZO6v7rKzsoODg4RERFVVVUNDQ0NDg0PEA8zMzNLTEtbXltmZmZydnF9gn2AgICPkI+ZmZmqqqq7u7vFxsXIzMgNDQwZGRkgICAhISEkJSMnKCcuMC4xMzE5Ozk7PTtBQkFCQkJDQ0Nna2eGhoaHh4ezuLLGysbd3d1wVGpAAAAA4UlEQVR42q2T1xqCMAyFk7QsBQeKA9x7j/d/OSm22CpX0nzcpA1/T05aAOuBVkMAScQFHLnEwoCo2f1TnQIGoVMewjZEjVFN4GH1Ue1Cn2jWqwfsOOj6wDwGvotsl/c8lv7KIq1eLOsT0HMFHMIE/RZyHnlphryT9zyV+8WH5e8yQw3wnQvgAFxPTKUVi555SHR/lOfLMgVTeDlSfN+TaoUsiTyeIm+bCkHvCA2FUKG48LDtYBZBknsYP/G8NTw0gaaHyuQf4H5pecrB/FYCT2sL9zAfy1Xyjou6L8X2W7YcLyBZCRtnq/zfAAAAAElFTkSuQmCC" /></a></p>
  <p>xThinker &copy; 2016</p>
  <p>Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme
  <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a></p>
  <a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-2x icon-rss-square"></i></a>
</footer>

</div>

  </nav>
  <main id="main">
    <header class="header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-circle-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">xThinker</div>
        
        <a href="javascript:;" class="header-icon waves-circle-light" id="menu-share">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header">
  <div class="container">
    <h1 class="author">xThinker</h1>
    <h5 class="subtitle">Android相关</h5>
  </div>
</header>

    <div class="container body-wrap">
      
  <ul class="post-list">
  
    <li class="post-list-item">
  <article id="post-SQLite临时文件及其编译参数" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/09/SQLite临时文件及其编译参数/">SQLite临时文件及其编译参数</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/database/">database</a></li></ul>
</div>
        <time datetime="2012-09-09T13:23:50.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-09
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/09/2677339.html">原文地址</a></p>
<h2 id="一、临时文件"><a href="#一、临时文件" class="headerlink" title="一、临时文件"></a>一、临时文件</h2><blockquote>
<p>尽管SQLite的数据库是由单一文件构成，然而事实上在SQLite运行时却存在着一些隐含的临时文件，这些临时文件是出于不同的目的而存在的，对于开发者而言，它们是透明的，因此在开发的过程中我们并不需要关注它们的存在。尽管如此，如果能对这些临时文件的产生机制和应用场景有着很好的理解，那么对我们今后应用程序的优化和维护都是极有帮助的。在SQLite中主要产生以下七种临时文件，如：</p>
<ul>
<li>回滚日志</li>
<li>主数据库日志</li>
<li>SQL语句日志</li>
<li>临时数据库文件</li>
<li>视图和子查询的临时持久化文件</li>
<li>临时索引文件</li>
<li>VACUUM命令使用的临时数据库文件</li>
</ul>
</blockquote>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/09/SQLite临时文件及其编译参数/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-inline-in-cpp" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/02/inline-in-cpp/">inline-in-cpp</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-09-02T14:13:10.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-02
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667395.html">原文地址</a></p>
<h2 id="与宏的比较"><a href="#与宏的比较" class="headerlink" title="与宏的比较"></a>与宏的比较</h2><p>内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define TABLE_COMP(x) ((x)&gt;0?(x):0)</span><br></pre></td></tr></table></figure></p>
<p>就定义了一个宏。</p>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/02/inline-in-cpp/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-extern-c" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/02/extern-c/">extern-c</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-09-02T10:42:11.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-02
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667730.html">原文链接</a></p>
<h2 id="extern-“C”的双重含义"><a href="#extern-“C”的双重含义" class="headerlink" title="extern “C”的双重含义"></a>extern “C”的双重含义</h2><ol>
<li>被它修饰的目标是“extern”</li>
<li>被它修饰的目标是“C”</li>
</ol>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/02/extern-c/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-const-in-cpp" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/09/01/const-in-cpp/">const-in-cpp</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-09-01T04:43:51.000Z" itemprop="datePublished" class="post-tiem">
  2012-09-01
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/01/2666741.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="用const修饰函数的参数"><a href="#用const修饰函数的参数" class="headerlink" title="用const修饰函数的参数"></a>用const修饰函数的参数</h2><p>如果参数作输出用，不论它是什么数据类型，不论它采用“指针传递”还是“引用传递”，都不能加const修饰，否则该参数将失去输出功能。<br>const只能修饰输入参数</p>
<p>如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针，起到保护作用。</p>
<p>例如StringCopy函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param strSource 输入参数</span><br><span class="line"> * @param strDestination 输出参数</span><br><span class="line"> */</span><br><span class="line">void StringCopy(char *strDestination, const char *strSource);</span><br></pre></td></tr></table></figure></p>
<p>给strSource加上const修饰后，如果函数体内的语句试图改动strSource的内容，编译器将指出错误。</p>
<p>如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const修饰。</p>
<p>例如不要将函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func1(int x)</span><br></pre></td></tr></table></figure></p>
<p>写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func1(const int x)</span><br></pre></td></tr></table></figure></p>
<p>同理不要将函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func2(A a)</span><br></pre></td></tr></table></figure></p>
<p>写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func2(const A a)</span><br></pre></td></tr></table></figure></p>
<p>其中A为用户自定义的数据类型。<br>对于非内部数据类型的参数而言，像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func(A a)</span><br></pre></td></tr></table></figure></p>
<p>这样声明的函数注定效率比较底。因为函数体内将产生A类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。<br>为了提高效率，可以将函数声明改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func(A &amp;a)</span><br></pre></td></tr></table></figure></p>
<p>因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。<br>但是函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func(A &amp;a)</span><br></pre></td></tr></table></figure></p>
<p>存在一个缺点：“引用传递”有可能改变参数a，这是我们不期望的。<br>解决这个问题很容易，加const修饰即可，因此函数最终成为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func(const A &amp;a)</span><br></pre></td></tr></table></figure></p>
<p>以此类推，是否应将<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func(int x)</span><br></pre></td></tr></table></figure></p>
<p>改写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void Func(const int &amp;x)</span><br></pre></td></tr></table></figure></p>
<p>以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</p>
<p>将“const &amp;”修饰输入参数的用法总结一下</p>
<p>对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const引用传递”，目的是提高效率。</p>
<p>对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。</p>
<h2 id="用const修饰函数的返回值"><a href="#用const修饰函数的返回值" class="headerlink" title="用const修饰函数的返回值"></a>用const修饰函数的返回值</h2><p>如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。<br>例如函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char * GetString(void);</span><br></pre></td></tr></table></figure></p>
<p>如下语句将出现编译错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *str = GetString();</span><br></pre></td></tr></table></figure></p>
<p>正确的用法是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char *str = GetString();</span><br></pre></td></tr></table></figure></p>
<p>如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。<br>例如不要把函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int GetInt(void)</span><br></pre></td></tr></table></figure></p>
<p>写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int GetInt(void)</span><br></pre></td></tr></table></figure></p>
<p>同理不要把函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A GetA(void)</span><br></pre></td></tr></table></figure></p>
<p>写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const A GetA(void)</span><br></pre></td></tr></table></figure></p>
<p>其中A为用户自定义的数据类型。</p>
<p>如果返回值不是内部数据类型，将函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A GetA(void)</span><br></pre></td></tr></table></figure></p>
<p>改写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const A &amp; GetA(void)</span><br></pre></td></tr></table></figure></p>
<p>的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</p>
<p>函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">    A &amp; operate = (const A &amp; other); // 赋值函数</span><br><span class="line">&#125;;</span><br><span class="line">A a, b, c; // a, b, c 为A 的对象</span><br><span class="line">a = b = c; // 正常的链式赋值</span><br><span class="line">(a = b) = c; // 不正常的链式赋值，但合法</span><br></pre></td></tr></table></figure></p>
<p>如果将赋值函数的返回值加const修饰，那么该返回值的内容不允许被改动.<br>上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。 </p>
<h2 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h2><p>任何不会修改数据成员（即函数中的变量）的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。<br>以下程序中，类stack的成员函数GetCount仅用于计数，从逻辑上讲GetCount应当为const函数。编译器将指出GetCount函数中的错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Stack</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Push(int elem);</span><br><span class="line">    int Pop(void);</span><br><span class="line">    int GetCount(void) const; // const 成员函数</span><br><span class="line">private:</span><br><span class="line">    int m_num;</span><br><span class="line">    int m_data[100];</span><br><span class="line">&#125;;</span><br><span class="line">int Stack::GetCount(void) const</span><br><span class="line">&#123;</span><br><span class="line">    ++ m_num; // 编译错误，企图修改数据成员m_num</span><br><span class="line">    Pop(); // 编译错误，企图调用非const 函数</span><br><span class="line">    return m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>const成员函数的声明看起来怪怪的：const关键字只能放在函数声明的尾部。<br>关于const函数的几点规则：</p>
<ul>
<li>a.const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。</li>
<li>b.const对象的成员是不可修改的，然而const对象通过指针维护的对象却是可以修改的。</li>
<li>c.const成员函数不可以修改对象的数据，不管对象是否具有const性质。它在编译时，以是否修改成员数据为依据，进行检查。</li>
<li>d.加上mutable修饰符的数据成员，对于任何情况下通过任何手段都可修改，自然此时的const成员函数是可以修改它的。</li>
</ul>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/09/01/const-in-cpp/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-文本相似度算法" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/05/文本相似度算法/">文本相似度算法</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/communication/">communication</a></li></ul>
</div>
        <time datetime="2012-05-05T14:25:40.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-05
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/05/2484972.html" target="_blank" rel="external">原文地址</a></p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/05/文本相似度算法/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-使用autotools制作makefile" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/05/使用autotools制作makefile/">使用autotools制作makefile</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/c/">c</a></li></ul>
</div>
        <time datetime="2012-05-05T14:24:25.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-05
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/05/2485099.html" target="_blank" rel="external">原文地址</a></p>
<h2 id="flat模式"><a href="#flat模式" class="headerlink" title="flat模式"></a>flat模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- ①#autoscan</span><br><span class="line">生成configure.scan</span><br><span class="line">- ②改写configure.scan</span><br><span class="line">AC_INIT(最终可执行文件名, 版本号)</span><br><span class="line">AM_INIT_AUTOMAKE</span><br><span class="line">AC_CONFIG_SRCDIR(源文件所在文件夹中的一个文件名，用于检测路径)</span><br><span class="line">AC_CONFIG_HEADER(config.h)</span><br><span class="line">AC_OUTPUT(Makefile)</span><br><span class="line">AC_PROG_RANLIB</span><br><span class="line">改写完毕后另存为configure.in</span><br><span class="line">- ③#aclocal</span><br><span class="line">- ④#autoconf</span><br><span class="line">- ⑤#autoheader</span><br><span class="line">- ⑥编辑Makefile.am</span><br><span class="line">AUTOMAKE_OPTIONS=foreign</span><br><span class="line">bin_PROGRAMS=可执行文件名1可执行文件名2 ......可执行文件名n</span><br><span class="line">可执行文件名1_SOURCES=该可执行文件生成所必须的源文件、头文件等，以空格分开</span><br><span class="line">可执行文件名2_SOURCES=该可执行文件生成所必须的源文件、头文件等，以空格分开</span><br><span class="line">......</span><br><span class="line">可执行文件名n_SOURCES=该可执行文件生成所必须的源文件、头文件等，以空格分开</span><br><span class="line">可执行文件名1_LDADD=-l库名</span><br><span class="line">......</span><br><span class="line">可执行文件名n_LDADD=-l库名</span><br><span class="line">- ⑦#automake --add-missing</span><br><span class="line">- ⑧#./configure</span><br><span class="line">- ⑨#make</span><br><span class="line">- ⑩生成可执行文件，运行。</span><br></pre></td></tr></table></figure>
<h2 id="deep模式"><a href="#deep模式" class="headerlink" title="deep模式"></a>deep模式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">以例子说明</span><br><span class="line">环境：Linux Redhat Enterprise</span><br><span class="line">文件结构：</span><br><span class="line">根目录：</span><br><span class="line">/rtcp</span><br><span class="line">子目录：</span><br><span class="line">/rtcp/src：包含server.c client.c</span><br><span class="line">/rtcp/include：包含rtcp.c rtcp.h</span><br><span class="line">目标：在根目录/rtcp下建立Makefile</span><br><span class="line">步骤：</span><br><span class="line">- ①进入/rtcp</span><br><span class="line">#autoscan</span><br><span class="line">产生configure.scan</span><br><span class="line">修改该文件：</span><br><span class="line">AM_INIT_AUTOMAKE</span><br><span class="line"># Checks for programs.</span><br><span class="line">AC_PROG_CC </span><br><span class="line">AM_PROG_CC_C_O</span><br><span class="line"># Checks for libraries. </span><br><span class="line">AC_PROG_RANLIB</span><br><span class="line">AC_OUTPUT(Makefile)</span><br><span class="line">保存为configure.in</span><br><span class="line">- ②</span><br><span class="line">#aclocal</span><br><span class="line">#autoconf</span><br><span class="line">#autoheader</span><br><span class="line">#gedit Makefile.am</span><br><span class="line">- ③编辑Makefile.am</span><br><span class="line">AUTOMAKE_OPTIONS=subdir-objects </span><br><span class="line">bin_PROGRAMS=server client </span><br><span class="line">server_SOURCES=src/server.c include/rtcp.c include/rtcp.h </span><br><span class="line">client_SOURCES=src/client.c include/rtcp.c include/rtcp.h </span><br><span class="line">server_LDADD=-lpthread </span><br><span class="line">client_LDADD=-lpthread</span><br><span class="line">server_LDFLAGS=-L/path/to/lib/pthread/</span><br><span class="line">client_LDFLAGS=-L/path/to/lib/pthread/</span><br><span class="line">保存</span><br><span class="line">- ④#automake --add-missing</span><br><span class="line">- ⑤#./configure</span><br><span class="line">- ⑥#make</span><br></pre></td></tr></table></figure>
        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/05/使用autotools制作makefile/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-Matlab作图：A律13折线" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/03/Matlab作图：A律13折线/">Matlab作图：A律13折线</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/communication/">communication</a></li></ul>
</div>
        <time datetime="2012-05-03T14:23:31.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-03
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/03/2481490.html" target="_blank" rel="external">原文地址</a></p>
<p>打开matlab，新建m文件，敲入以下代码后运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">x1=-1:0.001:-0.5;</span><br><span class="line">y1=0.25*x1-0.75;</span><br><span class="line">axis([-1.1,1.1,-1.1,1.1]);</span><br><span class="line">plot(x1,y1);</span><br><span class="line">hold on</span><br><span class="line">x2=-0.5:0.0001:-0.25;</span><br><span class="line">y2=0.5*x2-0.625;</span><br><span class="line">plot(x2,y2);</span><br><span class="line">x3=-0.25:0.00001:-0.125;</span><br><span class="line">y3=x3-0.5;</span><br><span class="line">plot(x3,y3);</span><br><span class="line">x4=-0.125:0.000001:-0.0625;</span><br><span class="line">y4=2*x4-0.375;</span><br><span class="line">plot(x4,y4);</span><br><span class="line">x5=-0.0625:0.0000001:-0.03125;</span><br><span class="line">y5=4*x5-0.25;</span><br><span class="line">plot(x5,y5);</span><br><span class="line">x6=-0.03125:0.0000001:-0.015625;</span><br><span class="line">y6=8*x6-0.125;</span><br><span class="line">plot(x6,y6);</span><br><span class="line">x7=-0.015625:0.0000001:0.015625;</span><br><span class="line">y7=16*x7;</span><br><span class="line">plot(x7,y7);</span><br><span class="line">x8=0.015625:0.0000001:0.03125;</span><br><span class="line">y8=8*x8+0.125;</span><br><span class="line">plot(x8,y8);</span><br><span class="line">x9=0.03125:0.0000001:0.0625;</span><br><span class="line">y9=4*x9+0.25;</span><br><span class="line">plot(x9,y9);</span><br><span class="line">x10=0.0625:0.000001:0.125;</span><br><span class="line">y10=2*x10+0.375;</span><br><span class="line">plot(x10,y10);</span><br><span class="line">x11=0.125:0.00001:0.25;</span><br><span class="line">y11=x11+0.5;</span><br><span class="line">plot(x11,y11);</span><br><span class="line">x12=0.25:0.0001:0.5;</span><br><span class="line">y12=0.5*x12+0.625;</span><br><span class="line">plot(x12,y12);</span><br><span class="line">x13=0.5:0.001:1;</span><br><span class="line">y13=0.25*x13+0.75;</span><br><span class="line">plot(x13,y13);</span><br><span class="line">grid on</span><br><span class="line">title(&apos;A律13折线&apos;);</span><br><span class="line">text(0,0,&apos;原点&apos;);</span><br><span class="line">set(gca,&apos;xtick&apos;,[-1:0.1:1]);</span><br><span class="line">set(gca,&apos;ytick&apos;,[-1:0.125:1]);</span><br></pre></td></tr></table></figure></p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/03/Matlab作图：A律13折线/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
    <li class="post-list-item">
  <article id="post-模拟频率、数字频率与模拟角频率" class="article article-type-post" itemscope itemprop="blogPost">
    
      


  
    <h3 class="post-title" itemprop="name">
      <a class="post-title-link" href="/2012/05/02/模拟频率、数字频率与模拟角频率/">模拟频率、数字频率与模拟角频率</a>
    </h3>
  



      <div class="post-meat flex-row">
        <div class="flex-col">
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/communication/">communication</a></li></ul>
</div>
        <time datetime="2012-05-02T14:19:48.000Z" itemprop="datePublished" class="post-tiem">
  2012-05-02
</time>
      </div>
      <div class="post-content" itemprop="postContent" >
        
          <p><a href="http://www.cnblogs.com/liangxiaxu/archive/2012/05/02/2479843.html" target="_blank" rel="external">原文地址</a></p>
<p>概念：<br>模拟频率f：每秒经历多少个周期，单位Hz，即1/s<br>模拟角频率Ω：每秒经历多少弧度，单位rad/s<br>数字频率w：每个采样点间隔之间的弧度，单位rad</p>
<p>表达式：<br>模拟频率f：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(2pi*f*t)</span><br></pre></td></tr></table></figure></p>
<p>模拟角频率Ω：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(Ω*t)</span><br></pre></td></tr></table></figure></p>
<p>数字频率w：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(w*n)=cos(Ω*T*n) [T为采样间隔时间]</span><br></pre></td></tr></table></figure></p>
<p>关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ω=2pi*f</span><br><span class="line">w=Ω*T</span><br></pre></td></tr></table></figure></p>
<p>推导：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cos(2pi*f*t)=cos(Ω*t)=cos(Ω*n*T)=cos(Ω*T*n)=cos(w*n)</span><br></pre></td></tr></table></figure></p>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x(n)=sin(n*4*PI/7)的数字频率=4*PI/7</span><br></pre></td></tr></table></figure></p>
<p>关键点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=n*T</span><br></pre></td></tr></table></figure></p>
<p>从时域角度理解：<br>模拟信号周期：<br>经过2<em>pi需多长时间，单位s；<br>example：f = 10Hz，则周期0.1s；<br>数字信号周期：<br>经过2</em>pi需多少个点，单位1；<br>example：f = 10Hz，fs = 20Hz，则周期2；<br>基准关系是2*pi</p>

        
      </div>
      <div class="post-footer clearfix">
        <a href="/2012/05/02/模拟频率、数字频率与模拟角频率/" class="post-more waves-button-light">MORE</a>
      </div>
    

  </article>


</li>
  
  </ul>
  
    <nav id="page-nav">
      <div class="inner">
        <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
      </div>
    </nav>
  


    </div>
  </main>
<div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-circle-light"><span class="icon icon-lg icon-chevron-up"></span></a>

<div class="global-share" id="global-share" data-title="xThinker" data-pic="/img/avatar.png" data-summary="梁夏旭的个人博客" data-url="https://hayukleung.github.io/page/2/index.html">
    <div class="tit">分享到：</div>
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" href="javascript:;" data-title="微博" data-service="tsina">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns" href="javascript:;" data-title="微信" data-service="weixin">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" href="javascript:;" data-title=" QQ" data-service="cqq">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" href="javascript:;" data-title=" Facebook" data-service="fb">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" href="javascript:;" data-title=" Twitter" data-service="twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="douban share-sns" href="javascript:;" data-title="豆瓣" data-service="douban">
          豆
        </a>
      </li>
    </ul>
 </div>


<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<script src="/js/main.js"></script>








</body>
</html>
