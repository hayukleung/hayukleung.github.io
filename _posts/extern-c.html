<!DOCTYPE html>
<html>
<head>
    <title>extern-c</title>

    <meta charset="UTF-8"/>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

    <meta name="HandheldFriendly" content="true"/>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

    <meta name="apple-mobile-web-app-capable" content="yes"/>

    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>

    <link href="../asset/gitbook/style.css" type="text/css" rel="stylesheet"/>
    <link href="../asset/gitbook/istyle.css" type="text/css" rel="stylesheet"/>

    <style type="text/css">
        
            span.md_line{margin-bottom:0.5em; display:block; line-height:1.89}
            .md_line br{ display: none;}
            
    </style>

    <script>
        var flowchat_options = {
            'x': 0, 'y': 0, 'line-width': 1, 'line-length': 50, 'text-margin': 10, 'font-size': 13,
            'font-color': '#3c3c3c', 'line-color': '#666666', 'element-color': '#666666', 'fill': 'transparent',
            'yes-text': 'yes', 'no-text': 'no', 'arrow-end': 'block', 'class': 'flowchart', 'scale': 1,
            'symbols': { 'start': {}, 'end': {}, 'condition': {}, 'inputoutput': {}, 'operation': {}, 'subroutine': {}}
        }
    </script>
    <script type="text/javascript" src="../asset/other/raphael-min.js"></script>
    <script type="text/javascript" src="../asset/other/flowchart.js"></script>
    <script type="text/javascript" src="../asset/other/echarts.min.js"></script>


</head>

<body>





<div data-basepath="/service/gitbook" class="book">
    <div class="book-summary">
        <ul class="summary">
            <li>
                <a href="../index.html">Blog</a>
            </li>
            <li class="divider"></li>
            
                
                
    
    <li data-level="1" class="chapter" data-path="readme.html">
        
        
        <a href="../readme.html" ><b>1</b> Markdown文字材料</a>
        
            
                    
                
        
    </li>

            
                
                
    
    <li data-level="2" class="chapter" data-path="_posts/index.html">
        
        
        <a href="#" ><b>2</b> _posts</a>
        
            
                    
                        <ul class="articles">
                            
                                
    
    <li data-level="2.1" class="chapter" data-path="_posts/C语言编译过程.html">
        
        
        <a href="../_posts/C语言编译过程.html" ><b>2.1</b> C语言编译过程</a>
        
    </li>

                            
                                
    
    <li data-level="2.2" class="chapter" data-path="_posts/Matlab作图：A律13折线.html">
        
        
        <a href="../_posts/Matlab作图：A律13折线.html" ><b>2.2</b> Matlab作图:A律13折线</a>
        
    </li>

                            
                                
    
    <li data-level="2.3" class="chapter" data-path="_posts/SQLite七种临时文件.html">
        
        
        <a href="../_posts/SQLite七种临时文件.html" ><b>2.3</b> SQLite七种临时文件</a>
        
    </li>

                            
                                
    
    <li data-level="2.4" class="chapter" data-path="_posts/SQLite临时文件及其编译参数.html">
        
        
        <a href="../_posts/SQLite临时文件及其编译参数.html" ><b>2.4</b> SQLite临时文件及其编译参数</a>
        
    </li>

                            
                                
    
    <li data-level="2.5" class="chapter" data-path="_posts/SQLite编译指令PRAGMA.html">
        
        
        <a href="../_posts/SQLite编译指令PRAGMA.html" ><b>2.5</b> SQLite编译指令PRAGMA</a>
        
    </li>

                            
                                
    
    <li data-level="2.6" class="chapter" data-path="_posts/const-in-cpp.html">
        
        
        <a href="../_posts/const-in-cpp.html" ><b>2.6</b> const-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.7" class="chapter active" data-path="_posts/extern-c.html">
        
        
        <a href="../_posts/extern-c.html" ><b>2.7</b> extern-c</a>
        
    </li>

                            
                                
    
    <li data-level="2.8" class="chapter" data-path="_posts/hello-world.html">
        
        
        <a href="../_posts/hello-world.html" ><b>2.8</b> Hello World</a>
        
    </li>

                            
                                
    
    <li data-level="2.9" class="chapter" data-path="_posts/inline-in-cpp.html">
        
        
        <a href="../_posts/inline-in-cpp.html" ><b>2.9</b> inline-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.10" class="chapter" data-path="_posts/resume.html">
        
        
        <a href="../_posts/resume.html" ><b>2.10</b> 个人简历</a>
        
    </li>

                            
                                
    
    <li data-level="2.11" class="chapter" data-path="_posts/segmentation-fault.html">
        
        
        <a href="../_posts/segmentation-fault.html" ><b>2.11</b> segmentation-fault</a>
        
    </li>

                            
                                
    
    <li data-level="2.12" class="chapter" data-path="_posts/symbol-lookup-error.html">
        
        
        <a href="../_posts/symbol-lookup-error.html" ><b>2.12</b> symbol-lookup-error</a>
        
    </li>

                            
                                
    
    <li data-level="2.13" class="chapter" data-path="_posts/test.html">
        
        
        <a href="../_posts/test.html" ><b>2.13</b> Test</a>
        
    </li>

                            
                                
    
    <li data-level="2.14" class="chapter" data-path="_posts/使用autotools制作makefile.html">
        
        
        <a href="../_posts/使用autotools制作makefile.html" ><b>2.14</b> 使用autotools制作makefile</a>
        
    </li>

                            
                                
    
    <li data-level="2.15" class="chapter" data-path="_posts/如何修改Linux系统日期与时间.html">
        
        
        <a href="../_posts/如何修改Linux系统日期与时间.html" ><b>2.15</b> 如何修改Linux系统日期与时间</a>
        
    </li>

                            
                                
    
    <li data-level="2.16" class="chapter" data-path="_posts/文本相似度算法.html">
        
        
        <a href="../_posts/文本相似度算法.html" ><b>2.16</b> 文本相似度算法</a>
        
    </li>

                            
                                
    
    <li data-level="2.17" class="chapter" data-path="_posts/标准C的四个常用宏定义.html">
        
        
        <a href="../_posts/标准C的四个常用宏定义.html" ><b>2.17</b> 标准C的四个常用宏定义</a>
        
    </li>

                            
                                
    
    <li data-level="2.18" class="chapter" data-path="_posts/模拟频率、数字频率与模拟角频率.html">
        
        
        <a href="../_posts/模拟频率、数字频率与模拟角频率.html" ><b>2.18</b> 模拟频率、数字频率与模拟角频率</a>
        
    </li>

                            
                        </ul>
                    
                
        
    </li>

            
        </ul>

    </div>

    <div class="book-body">
        <div class="body-inner">

            <div class="book-header" role="navigation">
                <h1>
                    <a href="../index.html" > Blog</a>
                </h1>
            </div>

            <div tabindex="-1" class="page-wrapper">
                <div class="page-inner">
                    <h2 class="post_title"> extern-c </h2>
                    <div class="post_body"> <p class="md_block">
    <span class="md_line md_line_dom_embed"><a class="md_compiled" href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667730.html">原文链接</a></span>
</p>


<h2 id="toc_0">extern &quot;C&quot;的双重含义</h2>

<ol>
<li>被它修饰的目标是“extern”</li>
<li>被它修饰的目标是“C”</li>
</ol>
<!--more-->
<a name="more"></a>

<p class="md_block">
    <span class="md_line">让我们来详细解读这两重含义。<br /></span>
    <span class="md_line">被extern &quot;C&quot;限定的函数或变量是extern类型的。<br /></span>
    <span class="md_line">extern 是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。记住下列语句：</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_has_block_below md_has_block_below_ol">
    <span class="md_line">仅仅是一个变量的声明，其并不是在定义变量a，并未为a分配内存空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出现连接错误。<br /></span>
    <span class="md_line">引用一个定义在其它模块的全局变量或函数（如全局函数或变量定义在A 模块，B欲引用）有两种方法：</span>
</p>


<ol>
<li>B模块中include模块A的头文件；</li>
<li>模块B中对欲引用的模块A的变量或函数重新声明一遍，并前加extern关键字。</li>
</ol>

<p class="md_block">
    <span class="md_line">通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A 的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。<br /></span>
    <span class="md_line">与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块中使用。因此，一个函数或变量只可能被本模块使用时，其不可能被extern &quot;C&quot;修饰。<br /></span>
    <span class="md_line">被extern &quot;C&quot;修饰的变量和函数是按照C语言方式编译和连接的。</span>
</p>


<h2 id="toc_1">未加extern &quot;C&quot;声明时的编译方式</h2>

<p class="md_block">
    <span class="md_line">首先看看C++中对类似C的函数是怎样编译的。<br /></span>
    <span class="md_line">作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为&quot;mangled name&quot;）。<br /></span>
    <span class="md_line">_foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。例如，在C++中，函数void foo(int x, int y)与void foo(int x, float y)编译生成的符号是不相同的，后者为_foo_int_float。<br /></span>
    <span class="md_line">同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以&quot;.&quot;来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。</span>
</p>


<h2 id="toc_2">未加extern &quot;C&quot;声明时的连接方式</h2>

<p class="md_block">
    <span class="md_line">假设在C++中，模块A的头文件如下：</span>
</p>

<div class="codehilite  highlight"><pre><span class="c1">// 模块A头文件moduleA.h</span>
<span class="cp">#ifndef MODULE_A_H</span>
<span class="cp">#define MODULE_A_H</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">在模块B中引用该函数：</span>
</p>

<div class="codehilite  highlight"><pre><span class="c1">// 模块B实现文件moduleB.cpp </span>
<span class="cp">#include &quot;moduleA.h&quot;</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">实际上，在连接阶段，连接器会从模块A生成的目标文件moduleA.obj中寻找_foo_int_int这样的符号。</span>
</p>


<h2 id="toc_3">加extern &quot;C&quot;声明后的编译和连接方式</h2>

<p class="md_block">
    <span class="md_line">加extern &quot;C&quot;声明后，模块A的头文件变为：</span>
</p>

<div class="codehilite  highlight"><pre><span class="c1">// 模块A头文件moduleA.h</span>
<span class="cp">#ifndef MODULE_A_H</span>
<span class="cp">#define MODULE_A_H</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_has_block_below md_has_block_below_ol">
    <span class="md_line">在模块B的实现文件中仍然调用foo(2, 3) ，其结果是：</span>
</p>


<ol>
<li>模块A 编译生成foo 的目标代码时，没有对其名字进行特殊处理，采用了C语言的方式；</li>
<li>连接器在为模块B 的目标代码寻找foo(2, 3)调用时，寻找的是未经修改的符号名_foo。</li>
</ol>

<p class="md_block">
    <span class="md_line">如果在模块A 中函数声明了foo 为extern &quot;C&quot;类型，而模块B中包含的是extern int foo(int x, int y)，则模块B找不到模块A中的函数；反之亦然。<br /></span>
    <span class="md_line">所以，可以用一句话概括extern &quot;C&quot;这个声明的真实目的（任何语言中的任何语法特性的诞生都不是随意而为的，来源于真实世界的需求驱动。我们在思考问题时，不能只停留在这个语言是怎么做的，还要问一问它为什么要这么做，动机是什么，这样我们可以更深入地理解许多问题）：实现C++与C及其它语言的混合编程。<br /></span>
    <span class="md_line">明白了C++ 中extern &quot;C&quot;的设立动机，我们下面来具体分析extern &quot;C&quot;通常的使用技巧。</span>
</p>


<h2 id="toc_4">extern &quot;C&quot;的惯用法</h2>

<p class="md_block">
    <span class="md_line">（1）在C++中引用C语言中的函数和变量，在包含C语言头文件（假设为cExample.h ）时，需进行下列处理：</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
<span class="cp">#include &quot;cExample.h&quot;</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_has_block_below md_has_block_below_blockquote">
    <span class="md_line">而在C语言的头文件中，对其外部函数只能指定为extern类型，C语言中不支持extern &quot;C&quot;声明，在.c文件中包含了extern &quot;C&quot;时会出现编译语法错误（error: expected identifier or ‘(’ before string constant ）。</span>
</p>


<blockquote>

<p class="md_block">
    <span class="md_line">C++ 引用C 函数工程例子</span>
</p>

</blockquote>
<div class="codehilite  highlight"><pre><span class="go">.</span>
<span class="go">|-- Makefile </span>
<span class="go">|-- cEx.c </span>
<span class="go">|-- cEx.h </span>
<span class="go">|-- libcEx.so </span>
<span class="go">`-- test </span>
<span class="go">    |-- Makefile </span>
<span class="go">    |-- cppTest.cpp </span>
<span class="go">    `—test</span>
</pre></div>

<!--block_code_end--><div class="codehilite  highlight"><pre><span class="c1">//cEx_h</span>
<span class="cp">#ifndef CEX_H</span>
<span class="cp">#define CEX_H</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="cp">#endif</span><span class="c1">//CEX_H</span>
<span class="c1">// vim: set tabstop=4 shiftwidth=4 expandtab:</span>
</pre></div>

<!--block_code_end--><div class="codehilite  highlight"><pre><span class="c1">//cEx_c</span>
<span class="cp">#include &quot;cEx.h&quot;</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// vim: set tabstop=4 shiftwidth=4 expandtab:</span>
</pre></div>

<!--block_code_end--><div class="codehilite  highlight"><pre><span class="c1">//cppTest_cpp</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
<span class="cp">#include &quot;cEx.h&quot;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// vim: set tabstop=4 shiftwidth=4 expandtab:</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_has_block_below md_has_block_below_blockquote">
    <span class="md_line">如果C++ 调用一个C 语言编写的.DLL 时，当包括.DLL 的头文件或声明接口函数时，应加extern &quot;C&quot; {} 。<br /></span>
    <span class="md_line">（2）在C中引用C++语言中的函数和变量时，C++的头文件需添加extern &quot;C&quot;，但是在C语言中不能直接引用声明了extern &quot;C&quot;的该头文件，应该仅将C文件中将C++中定义的extern &quot;C&quot;函数声明为extern类型。</span>
</p>


<blockquote>

<p class="md_block">
    <span class="md_line">C引用C++函数工程例子</span>
</p>

</blockquote>
<div class="codehilite  highlight"><pre><span class="go">.</span>
<span class="go">|-- Makefile </span>
<span class="go">|-- cppEx.cpp </span>
<span class="go">|-- cppEx.h </span>
<span class="go">|-- libcppEx.so </span>
<span class="go">`-- test </span>
<span class="go">    |-- Makefile </span>
<span class="go">    |-- cTest.c </span>
<span class="go">    `—- test</span>
</pre></div>

<!--block_code_end--><div class="codehilite  highlight"><pre><span class="c1">//cppEx_h</span>
<span class="cp">#ifndef CPPEX_H</span>
<span class="cp">#define CPPEX_H</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span><span class="c1">//CPPEX_H</span>
<span class="c1">// vim: set tabstop=4 shiftwidth=4 expandtab:</span>
</pre></div>

<!--block_code_end--><div class="codehilite  highlight"><pre><span class="c1">//cppEx_cpp</span>
<span class="cp">#include &quot;cppEx.h&quot;</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// vim: set tabstop=4 shiftwidth=4 expandtab:</span>
</pre></div>

<!--block_code_end--><div class="codehilite  highlight"><pre><span class="c1">//cTest_c</span>
<span class="c1">//the func add is  defined in outside module</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// vim: set tabstop=4 shiftwidth=4 expandtab:</span>
</pre></div>

<!--block_code_end--> </div>
                </div>
            </div>

        </div>

    </div>

</div>


<script type="text/javascript" src="../asset/gitbook/app.js"></script>

<script>require(["gitbook"], function (gitbook) {
    var config = {"fontSettings": {"theme": null, "family": "sans", "size": 2}};
    gitbook.start(config);
});

</script>





</body>

</html>