<!DOCTYPE html>
<html>
<head>
    <title>SQLite编译指令PRAGMA</title>

    <meta charset="UTF-8"/>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

    <meta name="HandheldFriendly" content="true"/>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

    <meta name="apple-mobile-web-app-capable" content="yes"/>

    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>

    <link href="../asset/gitbook/style.css" type="text/css" rel="stylesheet"/>
    <link href="../asset/gitbook/istyle.css" type="text/css" rel="stylesheet"/>

    <style type="text/css">
        
            span.md_line{margin-bottom:0.5em; display:block; line-height:1.89}
            .md_line br{ display: none;}
            
    </style>

    <script>
        var flowchat_options = {
            'x': 0, 'y': 0, 'line-width': 1, 'line-length': 50, 'text-margin': 10, 'font-size': 13,
            'font-color': '#3c3c3c', 'line-color': '#666666', 'element-color': '#666666', 'fill': 'transparent',
            'yes-text': 'yes', 'no-text': 'no', 'arrow-end': 'block', 'class': 'flowchart', 'scale': 1,
            'symbols': { 'start': {}, 'end': {}, 'condition': {}, 'inputoutput': {}, 'operation': {}, 'subroutine': {}}
        }
    </script>
    <script type="text/javascript" src="../asset/other/raphael-min.js"></script>
    <script type="text/javascript" src="../asset/other/flowchart.js"></script>
    <script type="text/javascript" src="../asset/other/echarts.min.js"></script>


</head>

<body>





<div data-basepath="/service/gitbook" class="book">
    <div class="book-summary">
        <ul class="summary">
            <li>
                <a href="../index.html">Blog</a>
            </li>
            <li class="divider"></li>
            
                
                
    
    <li data-level="1" class="chapter" data-path="readme.html">
        
        
        <a href="../readme.html" ><b>1</b> Markdown文字材料</a>
        
            
                    
                
        
    </li>

            
                
                
    
    <li data-level="2" class="chapter" data-path="posts/index.html">
        
        
        <a href="#" ><b>2</b> posts</a>
        
            
                    
                        <ul class="articles">
                            
                                
    
    <li data-level="2.1" class="chapter" data-path="posts/C语言编译过程.html">
        
        
        <a href="../posts/C语言编译过程.html" ><b>2.1</b> C语言编译过程</a>
        
    </li>

                            
                                
    
    <li data-level="2.2" class="chapter" data-path="posts/Matlab作图：A律13折线.html">
        
        
        <a href="../posts/Matlab作图：A律13折线.html" ><b>2.2</b> Matlab作图:A律13折线</a>
        
    </li>

                            
                                
    
    <li data-level="2.3" class="chapter" data-path="posts/SQLite七种临时文件.html">
        
        
        <a href="../posts/SQLite七种临时文件.html" ><b>2.3</b> SQLite七种临时文件</a>
        
    </li>

                            
                                
    
    <li data-level="2.4" class="chapter" data-path="posts/SQLite临时文件及其编译参数.html">
        
        
        <a href="../posts/SQLite临时文件及其编译参数.html" ><b>2.4</b> SQLite临时文件及其编译参数</a>
        
    </li>

                            
                                
    
    <li data-level="2.5" class="chapter active" data-path="posts/SQLite编译指令PRAGMA.html">
        
        
        <a href="../posts/SQLite编译指令PRAGMA.html" ><b>2.5</b> SQLite编译指令PRAGMA</a>
        
    </li>

                            
                                
    
    <li data-level="2.6" class="chapter" data-path="posts/const-in-cpp.html">
        
        
        <a href="../posts/const-in-cpp.html" ><b>2.6</b> const-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.7" class="chapter" data-path="posts/extern-c.html">
        
        
        <a href="../posts/extern-c.html" ><b>2.7</b> extern-c</a>
        
    </li>

                            
                                
    
    <li data-level="2.8" class="chapter" data-path="posts/hello-world.html">
        
        
        <a href="../posts/hello-world.html" ><b>2.8</b> Hello World</a>
        
    </li>

                            
                                
    
    <li data-level="2.9" class="chapter" data-path="posts/inline-in-cpp.html">
        
        
        <a href="../posts/inline-in-cpp.html" ><b>2.9</b> inline-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.10" class="chapter" data-path="posts/resume.html">
        
        
        <a href="../posts/resume.html" ><b>2.10</b> 个人简历</a>
        
    </li>

                            
                                
    
    <li data-level="2.11" class="chapter" data-path="posts/segmentation-fault.html">
        
        
        <a href="../posts/segmentation-fault.html" ><b>2.11</b> segmentation-fault</a>
        
    </li>

                            
                                
    
    <li data-level="2.12" class="chapter" data-path="posts/symbol-lookup-error.html">
        
        
        <a href="../posts/symbol-lookup-error.html" ><b>2.12</b> symbol-lookup-error</a>
        
    </li>

                            
                                
    
    <li data-level="2.13" class="chapter" data-path="posts/test.html">
        
        
        <a href="../posts/test.html" ><b>2.13</b> Test</a>
        
    </li>

                            
                                
    
    <li data-level="2.14" class="chapter" data-path="posts/使用autotools制作makefile.html">
        
        
        <a href="../posts/使用autotools制作makefile.html" ><b>2.14</b> 使用autotools制作makefile</a>
        
    </li>

                            
                                
    
    <li data-level="2.15" class="chapter" data-path="posts/如何修改Linux系统日期与时间.html">
        
        
        <a href="../posts/如何修改Linux系统日期与时间.html" ><b>2.15</b> 如何修改Linux系统日期与时间</a>
        
    </li>

                            
                                
    
    <li data-level="2.16" class="chapter" data-path="posts/文本相似度算法.html">
        
        
        <a href="../posts/文本相似度算法.html" ><b>2.16</b> 文本相似度算法</a>
        
    </li>

                            
                                
    
    <li data-level="2.17" class="chapter" data-path="posts/标准C的四个常用宏定义.html">
        
        
        <a href="../posts/标准C的四个常用宏定义.html" ><b>2.17</b> 标准C的四个常用宏定义</a>
        
    </li>

                            
                                
    
    <li data-level="2.18" class="chapter" data-path="posts/模拟频率、数字频率与模拟角频率.html">
        
        
        <a href="../posts/模拟频率、数字频率与模拟角频率.html" ><b>2.18</b> 模拟频率、数字频率与模拟角频率</a>
        
    </li>

                            
                        </ul>
                    
                
        
    </li>

            
        </ul>

    </div>

    <div class="book-body">
        <div class="body-inner">

            <div class="book-header" role="navigation">
                <h1>
                    <a href="../index.html" > Blog</a>
                </h1>
            </div>

            <div tabindex="-1" class="page-wrapper">
                <div class="page-inner">
                    <h2 class="post_title"> SQLite编译指令PRAGMA </h2>
                    <div class="post_body"> <p class="md_block">
    <span class="md_line md_line_dom_embed"><a class="md_compiled" href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/09/2677361.html">原文地址</a></span>
</p>


<h2 id="toc_0">SQLite支持的编译指令(pragma)</h2>

<blockquote>

<p class="md_block md_has_block_below md_has_block_below_ul">
    <span class="md_line">PRAGMA命令是用于修改SQLite库或查询SQLite库内部数据(non-table)的特殊命令。<br /></span>
    <span class="md_line">PRAGMA命令使用与其它SQLite命令(e.g. SELECT, INSERT)相同的接口，但在如下重要方面与其它命令不同:</span>
</p>


<ul>
<li>
<p class="md_block">
    <span class="md_line">在未来的SQLite版本中部分pragma可能被删除或添加，小心使用。</span>
</p></li>
<li>
<p class="md_block">
    <span class="md_line">当使用未知的pragma语句时不产生报错。未知的pragma仅仅会被忽略，即是说若是打错了pragma语句SQLite不会提示用户。</span>
</p></li>
<li>
<p class="md_block">
    <span class="md_line">一些pragma在SQL编译阶段生效而非执行阶段。即是说若使用C语言的sqlite3_compile(), sqlite3_step(), sqlite3_finalize() API (或类似的封装接口中)，pragma可能在调用sqlite3_compile()期间起作用。</span>
</p></li>
<li>
<p class="md_block">
    <span class="md_line">pragma命令不与其它SQL引擎兼容。</span>
</p></li>
</ul>
</blockquote>
<!--more-->
<a name="more"></a>

<blockquote>

<p class="md_block md_has_block_below md_has_block_below_ul">
    <span class="md_line">可用的pragma命令有如下四个基本类型：</span>
</p>


<ul>
<li>
<p class="md_block">
    <span class="md_line">用于察看当前数据库的模式。</span>
</p></li>
<li>
<p class="md_block">
    <span class="md_line">用于修改SQLite库的操作或查询当前的操作模式。</span>
</p></li>
<li>
<p class="md_block">
    <span class="md_line">用于查询或修改两个数据库的版本号，schema-version和user-version.</span>
</p></li>
<li>
<p class="md_block">
    <span class="md_line">用于调试库和校验数据库文件。</span>
</p></li>
</ul>

<p class="md_block">
    <span class="md_line">PRAGMA命令语法</span>
</p>


<p class="md_block">
    <span class="md_line">sql-statement::=PRAGMA name [= value] | PRAGMA function(arg)</span>
</p>


<p class="md_block">
    <span class="md_line">使用整数值value的pragma也可以使用符号表示，字符串&quot;on&quot;，&quot;true&quot;，和&quot;yes&quot;等同于1，&quot;off&quot;，&quot;false&quot;和&quot;no&quot;等同于0。这些字符串大小写不敏感且无须进行引用。无法识别的字符串被当作1且不会报错。value返回时是整数。</span>
</p>

</blockquote>

<h2 id="toc_1">用于修改SQLite库的操作的pragma</h2>

<ul>
<li>PRAGMA auto_vacuum;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA auto_vacuum = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或设置数据库的auto-vacuum标记。<br /></span>
    <span class="md_line">正常情况下，当提交一个从数据库中删除数据的事务时，数据库文件不改变大小。未使用的文件页被标记并在以后的添加操作中再次使用。这种情况下使用VACUUM命令释放删除得到的空间。<br /></span>
    <span class="md_line">当开启auto-vacuum，当提交一个从数据库中删除数据的事务时，数据库文件自动收缩， (VACUUM命令在auto-vacuum开启的数据库中不起作用)。数据库会在内部存储一些信息以便支持这一功能，这使得 数据库文件比不开启该选项时稍微大一些。<br /></span>
    <span class="md_line">只有在数据库中未建任何表时才能改变auto-vacuum标记。试图在已有表的情况下修改不会导致报错。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA cache_size;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA cache_size = Number-of-pages;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或修改SQLite一次存储在内存中的数据库文件页数。每页使用约1.5K内存，缺省的缓存大小是2000。若需要使用改变大量多行的UPDATE或DELETE命令，并且不介意SQLite使用更多的内存的话，可以增大缓存以提高性能。<br /></span>
    <span class="md_line">当使用pragma cache_size改变缓存大小时，改变仅对当前对话有效，当数据库关闭重新打开时缓存大小恢复到缺省大小。要想永久改变缓存大小，使用pragma default_cache_size = Number-of-pages;</span>
</p>

</blockquote>

<ul>
<li>PRAGMA case_sensitive_like;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA case_sensitive_like = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">LIKE运算符的缺省行为是忽略latin1字符的大小写。因此在缺省情况下&#39;a&#39; LIKE &#39;A&#39;的值为真。可以通过打开 case_sensitive_like pragma来改变这一缺省行为。当启用case_sensitive_like，&#39;a&#39; LIKE &#39;A&#39;为假而 &#39;a&#39; LIKE &#39;a&#39;依然为真。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA count_changes;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA count_changes = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改count-changes标记。正常情况下INSERT, UPDATE和DELETE语句不返回数据。 当开启count-changes，以上语句返回一行含一个整数值的数据——该语句插入，修改或删除的行数。 返回的行数不包括由触发器产生的插入，修改或删除等改变的行数。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA default_cache_size;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA default_cache_size = Number-of-pages;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或修改SQLite一次存储在内存中的数据库文件页数。每页使用约1.5K内存，它与cache_sizepragma类似，只是它永久性地改变缓存大小。 利用该pragma，你可以设定一次缓存大小，并且每次重新打开数据库时都继续使用该值。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA default_synchronous;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">该语句在2.8版本中可用，但在3.0版中被去掉了。这条pragma很危险且不推荐使用，安全起见在该文档中不涉及此pragma的用法。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA empty_result_callbacks;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA empty_result_callbacks = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改empty-result-callbacks标记。<br /></span>
    <span class="md_line">empty-result-callbacks标记仅仅影响sqlite3_exec API函数。正常情况下，empty-result-callbacks标记清空， 则对返回0行数据的命令不调用sqlite3_exec()的回叫函数，当设置了empty-result-callbacks，则调用回叫 函数一次，置第三个参数为0 (NULL).这使得使用sqlite3_exec() API的程序即使在一条查询不返回数据时依然检索字段名。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA encoding;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA encoding = &quot;UTF-8&quot;;<br /></span>
    <span class="md_line">PRAGMA encoding = &quot;UTF-16&quot;;<br /></span>
    <span class="md_line">PRAGMA encoding = &quot;UTF-16le&quot;;<br /></span>
    <span class="md_line">PRAGMA encoding = &quot;UTF-16be&quot;;</span>
</p>


<p class="md_block">
    <span class="md_line">在第一种形式中，若主数据库已创建，这条pragma返回主数据库使用得文本编码格式，为 &quot;UTF-8&quot;, &quot;UTF-16le&quot; (little-endian UTF-16 encoding) 或者&quot;UTF-16be&quot; (big-endian UTF-16 encoding)中的一种。 若主数据库未创建，返回值为当前会话创建的主数据库将要使用的文本编码格式。<br /></span>
    <span class="md_line">第二种及以后几种形式只在主数据库未创建时有效。这时该pragma设置当前会话创建的主数据库将要使用的文本编码格式。 &quot;UTF-16&quot;表示&quot;使用本机字节顺序的UTF-16编码&quot;。若这些形式在主数据库创建后使用，将被忽略且不产生任何效果。<br /></span>
    <span class="md_line">数据库的编码格式设置后不能够被改变。<br /></span>
    <span class="md_line">ATTACH命令创建的数据库使用与主数据库相同的编码格式。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA full_column_names;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA full_column_names = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改the full-column-names标记。该标记影响SQLite命名SELECT语句(当字段表达式为表-字段或通配符&quot;*&quot;时) 返回的字段名的方式。正常情况下，当SELECT语句将两个或多个表连接时，这类结果字段的返回名为___，当SELECT语句查询一个单独的表时， 返回字段名为___。当设置了full-column-names标记，返回的字段名将统一为___不管是否对表进行了连接。<br /></span>
    <span class="md_line">若short-column-names和full-column-names标记同时被设置，则使用full-column-names方式。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA fullfsync;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA fullfsync = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改fullfsync标记。该标记决定是否在支持的系统上使用F_FULLFSYNC同步模式。缺省值为off.截至目前(2006-02-10) 只有Mac OS X 系统支持F_FULLFSYNC.</span>
</p>

</blockquote>

<ul>
<li>PRAGMA page_size;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA page_size = bytes;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或设置page-size值。只有在未创建数据库时才能设置page-size。页面大小必须是2的整数倍且大于等于512小于等于8192。 上限可以通过在编译时修改宏定义SQLITE_MAX_PAGE_SIZE的值来改变。上限的上限是32768.</span>
</p>

</blockquote>

<ul>
<li>PRAGMA read_uncommitted;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA read_uncommitted = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询，设置或清除READ UNCOMMITTED isolation(读取未授权的分隔符).缺省的SQLite分隔符等级是SERIALIZABLE. 任何线程或进程可选用READ UNCOMMITTED isolation,但除了共享公共页和schema缓存的连接之间以外的地方也会 使用SERIALIZABLE.缓存共享通过sqlite3_enable_shared_cache() API开启，且只在运行同一线程的连接间有效。缺省情况下缓存共享是关闭的。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA short_column_names;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA short_column_names = 0 | 1;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改the short-column-names标记。该标记影响SQLite命名SELECT语句(当字段表达式为表-字段或通配符&quot;*&quot;时) 返回的字段名的方式。正常情况下，当SELECT语句将两个或多个表连接时， 这类结果字段的返回名为 ，当SELECT语句查询一个单独的表时， 返回字段名为。当设置了full-column-names标记，返回的字段名将统一为 不管是否对表进行了连接。<br /></span>
    <span class="md_line">若short-column-names和full-column-names标记同时被设置，则使用full-column-names方式。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA synchronous;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA synchronous = FULL; (2)<br /></span>
    <span class="md_line">PRAGMA synchronous = NORMAL; (1)<br /></span>
    <span class="md_line">PRAGMA synchronous = OFF; (0)</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改&quot;synchronous&quot;标记的设定。第一种形式(查询)返回整数值。 当synchronous设置为FULL (2), SQLite数据库引擎在紧急时刻会暂停以确定数据已经写入磁盘。 这使系统崩溃或电源出问题时能确保数据库在重起后不会损坏。FULL synchronous很安全但很慢。 当synchronous设置为NORMAL, SQLite数据库引擎在大部分紧急时刻会暂停，但不像FULL模式下那么频繁。 NORMAL模式下有很小的几率(但不是不存在)发生电源故障导致数据库损坏的情况。但实际上，在这种情况 下很可能你的硬盘已经不能使用，或者发生了其他的不可恢复的硬件错误。 设置为synchronous OFF (0)时，SQLite在传递数据给系统以后直接继续而不暂停。若运行SQLite的应用程序崩溃， 数据不会损伤，但在系统崩溃或写入数据时意外断电的情况下数据库可能会损坏。另一方面，在synchronous OFF时，一些操作可能会快50倍甚至更多。<br /></span>
    <span class="md_line">在SQLite 2中，缺省值为NORMAL.而在3中修改为FULL.</span>
</p>

</blockquote>

<ul>
<li>PRAGMA temp_store;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA temp_store = DEFAULT; (0)<br /></span>
    <span class="md_line">PRAGMA temp_store = FILE; (1)<br /></span>
    <span class="md_line">PRAGMA temp_store = MEMORY; (2)</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改&quot;temp_store&quot;参数的设置。当temp_store设置为DEFAULT (0),使用编译时的C预处理宏 TEMP_STORE来定义储存临时表和临时索引的位置。当设置为MEMORY (2)临时表和索引存放于内存中。 当设置为FILE (1)则存放于文件中。temp_store_directory pragma 可用于指定存放该文件的目录。当改变temp_store设置，所有已存在的临时表，索引，触发器及视图将被立即删除。<br /></span>
    <span class="md_line">库中的编译时C预处理标志TEMP_STORE可以覆盖该pragma设置。下面的表给出TEMP_STORE预处理宏和 temp_store pragma交互作用的总结：</span>
</p>

</blockquote>

<p class="md_block md_has_block_below md_has_block_below_ul">
    <span class="md_line">|TEMP_STORE|PRAGMA temp_store|临时表和索引使用的存储方式|<br /></span>
    <span class="md_line">|:-|:--|:--|<br /></span>
    <span class="md_line">|0 |any|文件| <br /></span>
    <span class="md_line">|1 |0  |文件| <br /></span>
    <span class="md_line">|1 |1  |文件|<br /></span>
    <span class="md_line">|1 |2  |内存|<br /></span>
    <span class="md_line">|2 |0  |内存|<br /></span>
    <span class="md_line">|2 |1  |文件|<br /></span>
    <span class="md_line">|2 |2  |内存|<br /></span>
    <span class="md_line">|3 |any|内存|</span>
</p>


<ul>
<li>PRAGMA temp_store_directory;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA temp_store_directory = &#39;directory-name&#39;;</span>
</p>


<p class="md_block">
    <span class="md_line">查询或更改&quot;temp_store_directory&quot;设置——存储临时表和索引的文件所在的目录。 仅在当前连接有效，在建立新连接时重置为缺省值。<br /></span>
    <span class="md_line">当改变了temp_store_directory设置，所有已有的临时表，索引，触发器，视图会被直接删除。 建议在数据库一打开时就设置好temp_store_directory.<br /></span>
    <span class="md_line">directory-name需用单引号引起来。要想恢复缺省目录，把directory-name设为空字符串。例如 PRAGMA temp_store_directory = &#39;&#39;.若directory-name未找到或不可写会引发错误。<br /></span>
    <span class="md_line">临时文件的缺省目录与主机的系统有关，使用Unix/Linux/OSX系统的主机，缺省目录是如下序列之中第一个可写的 /var/tmp, /usr/tmp, /tmp,current-directory.对于Windows NT,缺省目录由Windows决定，一般为 C:\Documents and Settings\user-name\Local Settings\Temp. SQLite创建的临时文件在使用完毕时就被unlink,所以操作系统可以在SQLite进程进行中自动删除临时文件。 于是，正常情况下不能通过ls 或 dir命令看到临时文件。</span>
</p>

</blockquote>

<h2 id="toc_2">用于查询数据库的schema的pragma</h2>

<ul>
<li>PRAGMA database_list;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">对每个打开的数据库，使用该数据库的信息调用一次回叫函数。使用包括附加的数据库名和索引名在内的参数。第一行用于主数据库，第二行用于存放临时表的临时数据库。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA foreign_key_list(table-name);</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">对于参数表中每个涉及到字段的外键，使用该外键的信息调用一次回叫函数。每个外键中的每个字段都将调用一次回叫函数。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA index_info(index-name);</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">对该索引涉及到的每个字段，使用字段信息(字段名，字段号)调用一次回叫函数。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA index_list(table-name);</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">对表中的每个索引，使用索引信息调用回叫函数。参数包括索引名和一个指示索引是否唯一的标志。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA table_info(table-name);</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">对于表中的每个字段，使用字段信息(字段名，数据类型，可否为空，缺省值)调用回叫函数。</span>
</p>

</blockquote>

<h2 id="toc_3">用于查询/更改版本信息的pragma</h2>

<ul>
<li>PRAGMA [database.]schema_version;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA [database.]schema_version = integer ;</span>
</p>

</blockquote>

<ul>
<li>PRAGMA [database.]user_version;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">PRAGMA [database.]user_version = integer ;</span>
</p>


<p class="md_block">
    <span class="md_line">这两条pragma分别用于设置schema-version和user-version的值。schema-version 和user-version均为32位有符号整数，存放于数据库头中。<br /></span>
    <span class="md_line">schema-version通常只由SQLite内部操作。每当数据库的schema改变时(创建或撤消表或索引)，SQLite 将这个值增大。schema版本在每一次query被执行时被SQLite所使用，以确定编译SQL query时内部cache的schema与编译后的query实际执行时数据库的schema相匹配。使用&quot;PRAGMA schema_version&quot;更改schema-version会破坏这一机制，有导致程序崩溃或数据库损坏的潜在危险。请小心使用！<br /></span>
    <span class="md_line">user-version不在SQLite内部使用，任何程序可以用它来做任何事。</span>
</p>

</blockquote>

<h2 id="toc_4">用于库debug的pragma</h2>

<ul>
<li>PRAGMA integrity_check;</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">该命令对整个数据库进行完整性检查，查找次序颠倒的记录，丢失的页，残缺的记录以及损坏的索引。若发现任何问题则返回一形容问题所在的字符串，若一切正常返回&quot;ok&quot;.</span>
</p>

</blockquote>

<ul>
<li>PRAGMA parser_trace = ON; (1) &amp;&amp; PRAGMA parser_trace = OFF; (0)</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">打开或关闭SQLite库中的SQL语法分析追踪，用于debug.只有当SQLite不使用NDEBUG宏进行编译时该pragma才可用。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA vdbe_trace = ON; (1) &amp;&amp; PRAGMA vdbe_trace = OFF; (0)</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">打开或关闭SQLite库中的虚拟数据库引擎追踪，用于debug.更多信息，察看 VDBE文档。</span>
</p>

</blockquote>

<ul>
<li>PRAGMA vdbe_listing = ON; (1) &amp;&amp; PRAGMA vdbe_listing = OFF; (0)</li>
</ul>

<blockquote>

<p class="md_block">
    <span class="md_line">打开或关闭虚拟机程序列表，当开启列表功能，整个程序的内容在执行前被打印出来，就像在每条语句之前自动执行EXPLAIN. 语句在打印列表之后正常执行。用于debug.更多信息，查看VDBE文档。</span>
</p>

</blockquote> </div>
                </div>
            </div>

        </div>

    </div>

</div>


<script type="text/javascript" src="../asset/gitbook/app.js"></script>

<script>require(["gitbook"], function (gitbook) {
    var config = {"fontSettings": {"theme": null, "family": "sans", "size": 2}};
    gitbook.start(config);
});

</script>





</body>

</html>