<!DOCTYPE html>
<html>
<head>
    <title>const-in-cpp</title>

    <meta charset="UTF-8"/>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

    <meta name="HandheldFriendly" content="true"/>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

    <meta name="apple-mobile-web-app-capable" content="yes"/>

    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>

    <link href="../asset/gitbook/style.css" type="text/css" rel="stylesheet"/>
    <link href="../asset/gitbook/istyle.css" type="text/css" rel="stylesheet"/>

    <style type="text/css">
        
            span.md_line{margin-bottom:0.5em; display:block; line-height:1.89}
            .md_line br{ display: none;}
            
    </style>

    <script>
        var flowchat_options = {
            'x': 0, 'y': 0, 'line-width': 1, 'line-length': 50, 'text-margin': 10, 'font-size': 13,
            'font-color': '#3c3c3c', 'line-color': '#666666', 'element-color': '#666666', 'fill': 'transparent',
            'yes-text': 'yes', 'no-text': 'no', 'arrow-end': 'block', 'class': 'flowchart', 'scale': 1,
            'symbols': { 'start': {}, 'end': {}, 'condition': {}, 'inputoutput': {}, 'operation': {}, 'subroutine': {}}
        }
    </script>
    <script type="text/javascript" src="../asset/other/raphael-min.js"></script>
    <script type="text/javascript" src="../asset/other/flowchart.js"></script>
    <script type="text/javascript" src="../asset/other/echarts.min.js"></script>


</head>

<body>





<div data-basepath="/service/gitbook" class="book">
    <div class="book-summary">
        <ul class="summary">
            <li>
                <a href="../index.html">Blog</a>
            </li>
            <li class="divider"></li>
            
                
                
    
    <li data-level="1" class="chapter" data-path="readme.html">
        
        
        <a href="../readme.html" ><b>1</b> Markdown文字材料</a>
        
            
                    
                
        
    </li>

            
                
                
    
    <li data-level="2" class="chapter" data-path="posts/index.html">
        
        
        <a href="#" ><b>2</b> posts</a>
        
            
                    
                        <ul class="articles">
                            
                                
    
    <li data-level="2.1" class="chapter" data-path="posts/C语言编译过程.html">
        
        
        <a href="../posts/C语言编译过程.html" ><b>2.1</b> C语言编译过程</a>
        
    </li>

                            
                                
    
    <li data-level="2.2" class="chapter" data-path="posts/Matlab作图：A律13折线.html">
        
        
        <a href="../posts/Matlab作图：A律13折线.html" ><b>2.2</b> Matlab作图:A律13折线</a>
        
    </li>

                            
                                
    
    <li data-level="2.3" class="chapter" data-path="posts/SQLite七种临时文件.html">
        
        
        <a href="../posts/SQLite七种临时文件.html" ><b>2.3</b> SQLite七种临时文件</a>
        
    </li>

                            
                                
    
    <li data-level="2.4" class="chapter" data-path="posts/SQLite临时文件及其编译参数.html">
        
        
        <a href="../posts/SQLite临时文件及其编译参数.html" ><b>2.4</b> SQLite临时文件及其编译参数</a>
        
    </li>

                            
                                
    
    <li data-level="2.5" class="chapter" data-path="posts/SQLite编译指令PRAGMA.html">
        
        
        <a href="../posts/SQLite编译指令PRAGMA.html" ><b>2.5</b> SQLite编译指令PRAGMA</a>
        
    </li>

                            
                                
    
    <li data-level="2.6" class="chapter active" data-path="posts/const-in-cpp.html">
        
        
        <a href="../posts/const-in-cpp.html" ><b>2.6</b> const-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.7" class="chapter" data-path="posts/extern-c.html">
        
        
        <a href="../posts/extern-c.html" ><b>2.7</b> extern-c</a>
        
    </li>

                            
                                
    
    <li data-level="2.8" class="chapter" data-path="posts/hello-world.html">
        
        
        <a href="../posts/hello-world.html" ><b>2.8</b> Hello World</a>
        
    </li>

                            
                                
    
    <li data-level="2.9" class="chapter" data-path="posts/inline-in-cpp.html">
        
        
        <a href="../posts/inline-in-cpp.html" ><b>2.9</b> inline-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.10" class="chapter" data-path="posts/resume.html">
        
        
        <a href="../posts/resume.html" ><b>2.10</b> 个人简历</a>
        
    </li>

                            
                                
    
    <li data-level="2.11" class="chapter" data-path="posts/segmentation-fault.html">
        
        
        <a href="../posts/segmentation-fault.html" ><b>2.11</b> segmentation-fault</a>
        
    </li>

                            
                                
    
    <li data-level="2.12" class="chapter" data-path="posts/symbol-lookup-error.html">
        
        
        <a href="../posts/symbol-lookup-error.html" ><b>2.12</b> symbol-lookup-error</a>
        
    </li>

                            
                                
    
    <li data-level="2.13" class="chapter" data-path="posts/test.html">
        
        
        <a href="../posts/test.html" ><b>2.13</b> Test</a>
        
    </li>

                            
                                
    
    <li data-level="2.14" class="chapter" data-path="posts/使用autotools制作makefile.html">
        
        
        <a href="../posts/使用autotools制作makefile.html" ><b>2.14</b> 使用autotools制作makefile</a>
        
    </li>

                            
                                
    
    <li data-level="2.15" class="chapter" data-path="posts/如何修改Linux系统日期与时间.html">
        
        
        <a href="../posts/如何修改Linux系统日期与时间.html" ><b>2.15</b> 如何修改Linux系统日期与时间</a>
        
    </li>

                            
                                
    
    <li data-level="2.16" class="chapter" data-path="posts/文本相似度算法.html">
        
        
        <a href="../posts/文本相似度算法.html" ><b>2.16</b> 文本相似度算法</a>
        
    </li>

                            
                                
    
    <li data-level="2.17" class="chapter" data-path="posts/标准C的四个常用宏定义.html">
        
        
        <a href="../posts/标准C的四个常用宏定义.html" ><b>2.17</b> 标准C的四个常用宏定义</a>
        
    </li>

                            
                                
    
    <li data-level="2.18" class="chapter" data-path="posts/模拟频率、数字频率与模拟角频率.html">
        
        
        <a href="../posts/模拟频率、数字频率与模拟角频率.html" ><b>2.18</b> 模拟频率、数字频率与模拟角频率</a>
        
    </li>

                            
                        </ul>
                    
                
        
    </li>

            
        </ul>

    </div>

    <div class="book-body">
        <div class="body-inner">

            <div class="book-header" role="navigation">
                <h1>
                    <a href="../index.html" > Blog</a>
                </h1>
            </div>

            <div tabindex="-1" class="page-wrapper">
                <div class="page-inner">
                    <h2 class="post_title"> const-in-cpp </h2>
                    <div class="post_body"> <p class="md_block">
    <span class="md_line md_line_dom_embed"><a class="md_compiled" href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/01/2666741.html">原文地址</a></span>
</p>


<h2 id="toc_0">用const修饰函数的参数</h2>

<p class="md_block">
    <span class="md_line">如果参数作输出用，不论它是什么数据类型，不论它采用“指针传递”还是“引用传递”，都不能加const修饰，否则该参数将失去输出功能。<br /></span>
    <span class="md_line">const只能修饰输入参数</span>
</p>


<p class="md_block">
    <span class="md_line">如果输入参数采用“指针传递”，那么加const修饰可以防止意外地改动该指针，起到保护作用。</span>
</p>


<p class="md_block">
    <span class="md_line">例如StringCopy函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="cm">/**</span>
<span class="cm"> * @param strSource 输入参数</span>
<span class="cm"> * @param strDestination 输出参数</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">StringCopy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">strDestination</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">strSource</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">给strSource加上const修饰后，如果函数体内的语句试图改动strSource的内容，编译器将指出错误。</span>
</p>


<p class="md_block">
    <span class="md_line">如果输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const修饰。</span>
</p>


<p class="md_block">
    <span class="md_line">例如不要将函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">写成</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func1</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">同理不要将函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">写成</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func2</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">其中A为用户自定义的数据类型。<br /></span>
    <span class="md_line">对于非内部数据类型的参数而言，像</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">这样声明的函数注定效率比较底。因为函数体内将产生A类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。<br /></span>
    <span class="md_line">为了提高效率，可以将函数声明改为</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">因为“引用传递”仅借用一下参数的别名而已，不需要产生临时对象。<br /></span>
    <span class="md_line">但是函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">存在一个缺点：“引用传递”有可能改变参数a，这是我们不期望的。<br /></span>
    <span class="md_line">解决这个问题很容易，加const修饰即可，因此函数最终成为</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">以此类推，是否应将</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">改写为</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">void</span> <span class="n">Func</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</span>
</p>


<p class="md_block">
    <span class="md_line">将“const &amp;”修饰输入参数的用法总结一下</span>
</p>


<p class="md_block">
    <span class="md_line">对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const引用传递”，目的是提高效率。</span>
</p>


<p class="md_block">
    <span class="md_line">对于内部数据类型的输入参数，不要将“值传递”的方式改为“const引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。</span>
</p>


<h2 id="toc_1">用const修饰函数的返回值</h2>

<p class="md_block">
    <span class="md_line">如果给以“指针传递”方式的函数返回值加const修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const修饰的同类型指针。<br /></span>
    <span class="md_line">例如函数：</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">GetString</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">如下语句将出现编译错误：</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">正确的用法是</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">GetString</span><span class="p">();</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">如果函数返回值采用“值传递方式”，由于函数会把返回值复制到外部临时的存储单元中，加const修饰没有任何价值。<br /></span>
    <span class="md_line">例如不要把函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="kt">int</span> <span class="n">GetInt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">写成</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">GetInt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">同理不要把函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="n">A</span> <span class="n">GetA</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">写成</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">const</span> <span class="n">A</span> <span class="n">GetA</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">其中A为用户自定义的数据类型。</span>
</p>


<p class="md_block">
    <span class="md_line">如果返回值不是内部数据类型，将函数</span>
</p>

<div class="codehilite  highlight"><pre><span class="n">A</span> <span class="n">GetA</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">改写为</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span> <span class="n">GetA</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</span>
</p>


<p class="md_block">
    <span class="md_line">函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。例如：</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="o">&amp;</span> <span class="n">operate</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span> <span class="n">other</span><span class="p">);</span> <span class="c1">// 赋值函数</span>
<span class="p">};</span>
<span class="n">A</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// a, b, c 为A 的对象</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 正常的链式赋值</span>
<span class="p">(</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 不正常的链式赋值，但合法</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">如果将赋值函数的返回值加const修饰，那么该返回值的内容不允许被改动.<br /></span>
    <span class="md_line">上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。 </span>
</p>


<h2 id="toc_2">const成员函数</h2>

<p class="md_block">
    <span class="md_line">任何不会修改数据成员（即函数中的变量）的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改了数据成员，或者调用了其它非const 成员函数，编译器将指出错误，这无疑会提高程序的健壮性。<br /></span>
    <span class="md_line">以下程序中，类stack的成员函数GetCount仅用于计数，从逻辑上讲GetCount应当为const函数。编译器将指出GetCount函数中的错误。</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">class</span> <span class="nc">Stack</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">Push</span><span class="p">(</span><span class="kt">int</span> <span class="n">elem</span><span class="p">);</span>
    <span class="kt">int</span> <span class="nf">Pop</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">GetCount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// const 成员函数</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_data</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
<span class="p">};</span>
<span class="kt">int</span> <span class="n">Stack</span><span class="o">::</span><span class="n">GetCount</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="o">++</span> <span class="n">m_num</span><span class="p">;</span> <span class="c1">// 编译错误，企图修改数据成员m_num</span>
    <span class="n">Pop</span><span class="p">();</span> <span class="c1">// 编译错误，企图调用非const 函数</span>
    <span class="k">return</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block md_has_block_below md_has_block_below_ul">
    <span class="md_line">const成员函数的声明看起来怪怪的：const关键字只能放在函数声明的尾部。<br /></span>
    <span class="md_line">关于const函数的几点规则：</span>
</p>


<ul>
<li>a.const对象只能访问const成员函数，而非const对象可以访问任意的成员函数，包括const成员函数。</li>
<li>b.const对象的成员是不可修改的，然而const对象通过指针维护的对象却是可以修改的。</li>
<li>c.const成员函数不可以修改对象的数据，不管对象是否具有const性质。它在编译时，以是否修改成员数据为依据，进行检查。</li>
<li>d.加上mutable修饰符的数据成员，对于任何情况下通过任何手段都可修改，自然此时的const成员函数是可以修改它的。</li>
</ul> </div>
                </div>
            </div>

        </div>

    </div>

</div>


<script type="text/javascript" src="../asset/gitbook/app.js"></script>

<script>require(["gitbook"], function (gitbook) {
    var config = {"fontSettings": {"theme": null, "family": "sans", "size": 2}};
    gitbook.start(config);
});

</script>





</body>

</html>