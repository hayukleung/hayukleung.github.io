<!DOCTYPE html>
<html>
<head>
    <title>inline-in-cpp</title>

    <meta charset="UTF-8"/>

    <meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>

    <meta name="HandheldFriendly" content="true"/>

    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

    <meta name="apple-mobile-web-app-capable" content="yes"/>

    <meta name="apple-mobile-web-app-status-bar-style" content="black"/>

    <link href="../asset/gitbook/style.css" type="text/css" rel="stylesheet"/>
    <link href="../asset/gitbook/istyle.css" type="text/css" rel="stylesheet"/>

    <style type="text/css">
        
            span.md_line{margin-bottom:0.5em; display:block; line-height:1.89}
            .md_line br{ display: none;}
            
    </style>

    <script>
        var flowchat_options = {
            'x': 0, 'y': 0, 'line-width': 1, 'line-length': 50, 'text-margin': 10, 'font-size': 13,
            'font-color': '#3c3c3c', 'line-color': '#666666', 'element-color': '#666666', 'fill': 'transparent',
            'yes-text': 'yes', 'no-text': 'no', 'arrow-end': 'block', 'class': 'flowchart', 'scale': 1,
            'symbols': { 'start': {}, 'end': {}, 'condition': {}, 'inputoutput': {}, 'operation': {}, 'subroutine': {}}
        }
    </script>
    <script type="text/javascript" src="../asset/other/raphael-min.js"></script>
    <script type="text/javascript" src="../asset/other/flowchart.js"></script>
    <script type="text/javascript" src="../asset/other/echarts.min.js"></script>


</head>

<body>





<div data-basepath="/service/gitbook" class="book">
    <div class="book-summary">
        <ul class="summary">
            <li>
                <a href="../index.html">Blog</a>
            </li>
            <li class="divider"></li>
            
                
                
    
    <li data-level="1" class="chapter" data-path="readme.html">
        
        
        <a href="../readme.html" ><b>1</b> Markdown文字材料</a>
        
            
                    
                
        
    </li>

            
                
                
    
    <li data-level="2" class="chapter" data-path="posts/index.html">
        
        
        <a href="#" ><b>2</b> posts</a>
        
            
                    
                        <ul class="articles">
                            
                                
    
    <li data-level="2.1" class="chapter" data-path="posts/C语言编译过程.html">
        
        
        <a href="../posts/C语言编译过程.html" ><b>2.1</b> C语言编译过程</a>
        
    </li>

                            
                                
    
    <li data-level="2.2" class="chapter" data-path="posts/Matlab作图：A律13折线.html">
        
        
        <a href="../posts/Matlab作图：A律13折线.html" ><b>2.2</b> Matlab作图:A律13折线</a>
        
    </li>

                            
                                
    
    <li data-level="2.3" class="chapter" data-path="posts/SQLite七种临时文件.html">
        
        
        <a href="../posts/SQLite七种临时文件.html" ><b>2.3</b> SQLite七种临时文件</a>
        
    </li>

                            
                                
    
    <li data-level="2.4" class="chapter" data-path="posts/SQLite临时文件及其编译参数.html">
        
        
        <a href="../posts/SQLite临时文件及其编译参数.html" ><b>2.4</b> SQLite临时文件及其编译参数</a>
        
    </li>

                            
                                
    
    <li data-level="2.5" class="chapter" data-path="posts/SQLite编译指令PRAGMA.html">
        
        
        <a href="../posts/SQLite编译指令PRAGMA.html" ><b>2.5</b> SQLite编译指令PRAGMA</a>
        
    </li>

                            
                                
    
    <li data-level="2.6" class="chapter" data-path="posts/const-in-cpp.html">
        
        
        <a href="../posts/const-in-cpp.html" ><b>2.6</b> const-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.7" class="chapter" data-path="posts/extern-c.html">
        
        
        <a href="../posts/extern-c.html" ><b>2.7</b> extern-c</a>
        
    </li>

                            
                                
    
    <li data-level="2.8" class="chapter" data-path="posts/hello-world.html">
        
        
        <a href="../posts/hello-world.html" ><b>2.8</b> Hello World</a>
        
    </li>

                            
                                
    
    <li data-level="2.9" class="chapter active" data-path="posts/inline-in-cpp.html">
        
        
        <a href="../posts/inline-in-cpp.html" ><b>2.9</b> inline-in-cpp</a>
        
    </li>

                            
                                
    
    <li data-level="2.10" class="chapter" data-path="posts/resume.html">
        
        
        <a href="../posts/resume.html" ><b>2.10</b> 个人简历</a>
        
    </li>

                            
                                
    
    <li data-level="2.11" class="chapter" data-path="posts/segmentation-fault.html">
        
        
        <a href="../posts/segmentation-fault.html" ><b>2.11</b> segmentation-fault</a>
        
    </li>

                            
                                
    
    <li data-level="2.12" class="chapter" data-path="posts/symbol-lookup-error.html">
        
        
        <a href="../posts/symbol-lookup-error.html" ><b>2.12</b> symbol-lookup-error</a>
        
    </li>

                            
                                
    
    <li data-level="2.13" class="chapter" data-path="posts/test.html">
        
        
        <a href="../posts/test.html" ><b>2.13</b> Test</a>
        
    </li>

                            
                                
    
    <li data-level="2.14" class="chapter" data-path="posts/使用autotools制作makefile.html">
        
        
        <a href="../posts/使用autotools制作makefile.html" ><b>2.14</b> 使用autotools制作makefile</a>
        
    </li>

                            
                                
    
    <li data-level="2.15" class="chapter" data-path="posts/如何修改Linux系统日期与时间.html">
        
        
        <a href="../posts/如何修改Linux系统日期与时间.html" ><b>2.15</b> 如何修改Linux系统日期与时间</a>
        
    </li>

                            
                                
    
    <li data-level="2.16" class="chapter" data-path="posts/文本相似度算法.html">
        
        
        <a href="../posts/文本相似度算法.html" ><b>2.16</b> 文本相似度算法</a>
        
    </li>

                            
                                
    
    <li data-level="2.17" class="chapter" data-path="posts/标准C的四个常用宏定义.html">
        
        
        <a href="../posts/标准C的四个常用宏定义.html" ><b>2.17</b> 标准C的四个常用宏定义</a>
        
    </li>

                            
                                
    
    <li data-level="2.18" class="chapter" data-path="posts/模拟频率、数字频率与模拟角频率.html">
        
        
        <a href="../posts/模拟频率、数字频率与模拟角频率.html" ><b>2.18</b> 模拟频率、数字频率与模拟角频率</a>
        
    </li>

                            
                        </ul>
                    
                
        
    </li>

            
        </ul>

    </div>

    <div class="book-body">
        <div class="body-inner">

            <div class="book-header" role="navigation">
                <h1>
                    <a href="../index.html" > Blog</a>
                </h1>
            </div>

            <div tabindex="-1" class="page-wrapper">
                <div class="page-inner">
                    <h2 class="post_title"> inline-in-cpp </h2>
                    <div class="post_body"> <p class="md_block">
    <span class="md_line md_line_dom_embed"><a class="md_compiled" href="http://www.cnblogs.com/liangxiaxu/archive/2012/09/02/2667395.html">原文地址</a></span>
</p>


<h2 id="toc_0">与宏的比较</h2>

<p class="md_block">
    <span class="md_line">内联函数的功能和预处理宏的功能相似。相信大家都用过预处理宏，我们会经常定义一些宏，如：</span>
</p>

<div class="codehilite  highlight"><pre><span class="cp">#define TABLE_COMP(x) ((x)&gt;0?(x):0)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">就定义了一个宏。</span>
</p>

<!--more-->
<a name="more"></a>

<p class="md_block md_has_block_below md_has_block_below_ol">
    <span class="md_line">为什么要使用宏呢？因为函数的调用必须要将程序执行的顺序转移到函数所存放在内存中的某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去执行前要保存现场并记忆执行的地址，转回后要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。而宏只是在预处理的地方把代码展开，不需要额外的空间和时间方面的开销，所以调用一个宏比调用一个函数更有效率。<br /></span>
    <span class="md_line">但是宏也有很多的不尽人意的地方：</span>
</p>


<ol>
<li>宏不能访问对象的私有成员。</li>
<li>宏的定义很容易产生二意性。</li>
</ol>

<p class="md_block">
    <span class="md_line">我们举个例子：</span>
</p>

<div class="codehilite  highlight"><pre><span class="cp">#define TABLE_MULTI(x) (x*x)</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">我们用一个数字去调用它：</span>
</p>

<div class="codehilite  highlight"><pre><span class="n">TABLE_MULTI</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">这样看上去没有什么错误，结果返回100是正确的，但是如果我们用：</span>
</p>

<div class="codehilite  highlight"><pre><span class="n">TABLE_MULTI</span><span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="mi">10</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">去调用的话，我们期望的结果是400，而宏的调用结果是(10+10*10+10)，结果是120，这显然不是我们要得到的结果。避免这些错误的方法，一是给宏的参数都加上括号：</span>
</p>

<div class="codehilite  highlight"><pre><span class="cp">#define TABLE_MULTI(x) ((x)*(x))</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">这样可以确保不会出错，但是，即使使用了这种定义，这个宏依然有可能出错，例如使用：</span>
</p>

<div class="codehilite  highlight"><pre><span class="n">TABLE_MULTI</span><span class="p">(</span><span class="n">a</span><span class="o">++</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">调用它，他们本意是希望得到(a+1)<em>(a+1)的结果，而实际上呢？我们可以看看宏的展开结果：(a++)</em>(a++)，如果a的值是4，我们得到的结果是4<em>4 = 16，a = 6。而我们期望的结果是5</em>5=25，这又出现了问题。<br /></span>
    <span class="md_line">事实上，在一些C的库函数中也有这些问题。例如：</span>
</p>

<div class="codehilite  highlight"><pre><span class="n">Toupper</span><span class="p">(</span><span class="o">*</span><span class="n">pChar</span><span class="o">++</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">就会对pChar执行两次++操作，因为Toupper实际上也是一个宏。<br /></span>
    <span class="md_line">我们可以看到宏有一些难以避免的问题，怎么解决呢？<br /></span>
    <span class="md_line">下面就是用我要介绍的内联函数来解决这些问题，我们可以使用内联函数来取代宏的定义。而且事实上我们可以用内联函数完全取代预处理宏。<br /></span>
    <span class="md_line">内联函数和宏的区别在于，宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的。而且内联函数是真正的函数，只是在需要用到的时候，内联函数像宏一样的展开，所以取消了函数的参数压栈，减少了调用的开销。你可以象调用函数一样来调用内联函数，而不必担心会产生于处理宏的一些问题。<br /></span>
    <span class="md_line">我们可以用inline来定义内联函数，不过，任何在类的说明部分定义的函数都会被自动的认为是内联函数。</span>
</p>


<h2 id="toc_1">内联函数的用法</h2>

<p class="md_block">
    <span class="md_line">内联函数必须是和函数体申明在一起，才有效。像这样的申明：</span>
</p>

<div class="codehilite  highlight"><pre><span class="kr">inline</span> <span class="nf">Tablefunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">I</span><span class="p">);</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">是没有效果的，编译器只是把函数作为普通的函数申明，我们必须定义函数体：</span>
</p>

<div class="codehilite  highlight"><pre><span class="kr">inline</span> <span class="nf">tablefunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">I</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">I</span><span class="o">*</span><span class="n">I</span><span class="p">};</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">这样我们才算定义了一个内联函数。我们可以把它作为一般的函数一样调用。但是执行速度确比一般函数的执行速度要快。<br /></span>
    <span class="md_line">我们也可以将定义在类的外部的函数定义为内联函数，比如：</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">class</span> <span class="nc">TableClass</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">I</span><span class="p">,</span><span class="n">j</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">add</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">I</span><span class="o">+</span><span class="n">j</span><span class="p">;};</span>
    <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dec</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">I</span><span class="o">-</span><span class="n">j</span><span class="p">;}</span>
    <span class="kt">int</span> <span class="nf">GetNum</span><span class="p">();</span> 
<span class="p">}</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="n">tableclass</span><span class="o">::</span><span class="n">GetNum</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">I</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">上面申明的三个函数都是内联函数。在C++中，在类的内部定义了函数体的函数，被默认为是内联函数。而不管你是否有inline关键字。<br /></span>
    <span class="md_line">内联函数在C++类中，应用最广的，应该是用来定义存取函数。我们定义的类中一般会把数据成员定义成私有的或者保护的，这样，外界就不能直接读写我们类成员的数据了。<br /></span>
    <span class="md_line">对于私有或者保护成员的读写就必须使用成员接口函数来进行。如果我们把这些读写成员函数定义成内联函数的话，将会获得比较好的效率。</span>
</p>

<div class="codehilite  highlight"><pre><span class="k">class</span> <span class="nc">sample</span>
<span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">nTest</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">readtest</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">nTest</span><span class="p">;}</span>
    <span class="kt">void</span> <span class="n">settest</span><span class="p">(</span><span class="kt">int</span> <span class="n">I</span><span class="p">)</span> <span class="p">{</span><span class="n">nTest</span><span class="o">=</span><span class="n">I</span><span class="p">;}</span>
<span class="p">}</span>
</pre></div>

<!--block_code_end-->
<p class="md_block">
    <span class="md_line">当然，内联函数也有一定的局限性。就是函数中的执行代码不能太多了，如果，内联函数的函数体过大，一般的编译器会放弃内联方式，而采用普通的方式调用函数。这样，内联函数就和普通函数执行效率一样了。</span>
</p>


<h2 id="toc_2">使用内联函数注意事项</h2>

<p class="md_block md_has_block_below md_has_block_below_ol">
    <span class="md_line">内联函数具有一般函数的特性，它与一般函数所不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。在使用内联函数时，应注意如下几点：</span>
</p>


<ol>
<li>在内联函数内不允许用循环语句和开关语句。</li>
</ol>

<p class="md_block md_has_block_below md_has_block_below_ol">
    <span class="md_line">如果内联函数有这些语句，则编译将该函数视同普通函数那样产生函数调用代码,递归函数（自己调用自己的函数）是不能被用来做内联函数的。内联函数只适合于只有1～5行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，所以也没有必要用内联函数实现。</span>
</p>


<ol>
<li>内联函数的定义必须出现在内联函数第一次被调用之前。</li>
<li>本栏目讲到的类结构中所有在类说明内部定义的函数是内联函数。</li>
</ol> </div>
                </div>
            </div>

        </div>

    </div>

</div>


<script type="text/javascript" src="../asset/gitbook/app.js"></script>

<script>require(["gitbook"], function (gitbook) {
    var config = {"fontSettings": {"theme": null, "family": "sans", "size": 2}};
    gitbook.start(config);
});

</script>





</body>

</html>